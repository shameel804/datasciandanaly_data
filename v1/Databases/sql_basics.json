[
    {
        "q": "What does SQL stand for?",
        "type": "mcq",
        "o": [
            "Structured Query Language",
            "Simple Query Language",
            "Standard Query Logic",
            "System Query Language"
        ]
    },
    {
        "q": "The _____ statement is used to retrieve data from a database.",
        "type": "fill_blank",
        "answers": [
            "SELECT"
        ],
        "other_options": [
            "INSERT",
            "UPDATE",
            "DELETE"
        ]
    },
    {
        "q": "SQL is a case-sensitive language for keywords.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this SQL query?",
        "type": "mcq",
        "c": "SELECT 1 + 1;",
        "o": [
            "2",
            "11",
            "1 + 1",
            "Error"
        ]
    },
    {
        "q": "Match the SQL command with its category:",
        "type": "match",
        "left": [
            "SELECT",
            "INSERT",
            "CREATE",
            "GRANT"
        ],
        "right": [
            "DQL",
            "DML",
            "DDL",
            "DCL"
        ]
    },
    {
        "q": "Rearrange the basic SQL query structure:",
        "type": "rearrange",
        "words": [
            "SELECT",
            "FROM",
            "WHERE",
            "ORDER BY",
            "LIMIT"
        ]
    },
    {
        "q": "Which keyword is used to filter records in SQL?",
        "type": "mcq",
        "o": [
            "WHERE",
            "FILTER",
            "HAVING",
            "SEARCH"
        ]
    },
    {
        "q": "The _____ clause is used to sort query results.",
        "type": "fill_blank",
        "answers": [
            "ORDER BY"
        ],
        "other_options": [
            "SORT BY",
            "GROUP BY",
            "ARRANGE BY"
        ]
    },
    {
        "q": "The asterisk (*) in SELECT * retrieves all columns.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT 'Hello' || ' ' || 'World';",
        "o": [
            "Hello World",
            "HelloWorld",
            "Hello || World",
            "Error"
        ]
    },
    {
        "q": "Match the SQL data type with its purpose:",
        "type": "match",
        "left": [
            "VARCHAR",
            "INTEGER",
            "DATE",
            "BOOLEAN"
        ],
        "right": [
            "Text data",
            "Whole numbers",
            "Calendar values",
            "True/False"
        ]
    },
    {
        "q": "Rearrange the SQL statement execution order:",
        "type": "rearrange",
        "words": [
            "FROM",
            "WHERE",
            "SELECT",
            "ORDER BY",
            "LIMIT"
        ]
    },
    {
        "q": "Which clause is used to combine rows from two tables?",
        "type": "mcq",
        "o": [
            "JOIN",
            "MERGE",
            "COMBINE",
            "UNION ALL"
        ]
    },
    {
        "q": "The _____ join returns all rows from both tables where there is a match.",
        "type": "fill_blank",
        "answers": [
            "INNER"
        ],
        "other_options": [
            "OUTER",
            "LEFT",
            "RIGHT"
        ]
    },
    {
        "q": "INNER JOIN returns rows even when there is no match.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT COUNT(*) FROM (SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) t;",
        "o": [
            "3",
            "1",
            "6",
            "Error"
        ]
    },
    {
        "q": "Match the join type with its behavior:",
        "type": "match",
        "left": [
            "INNER JOIN",
            "LEFT JOIN",
            "RIGHT JOIN",
            "FULL JOIN"
        ],
        "right": [
            "Matching rows only",
            "All left rows",
            "All right rows",
            "All rows from both"
        ]
    },
    {
        "q": "Rearrange the join query components:",
        "type": "rearrange",
        "words": [
            "SELECT",
            "FROM table1",
            "JOIN table2",
            "ON condition",
            "WHERE filter"
        ]
    },
    {
        "q": "Which function counts the number of rows?",
        "type": "mcq",
        "o": [
            "COUNT()",
            "SUM()",
            "TOTAL()",
            "NUM()"
        ]
    },
    {
        "q": "The _____ function calculates the average value.",
        "type": "fill_blank",
        "answers": [
            "AVG"
        ],
        "other_options": [
            "MEAN",
            "AVERAGE",
            "MID"
        ]
    },
    {
        "q": "GROUP BY is used with aggregate functions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT MAX(5, 10, 3);",
        "o": [
            "Error",
            "10",
            "5",
            "3"
        ]
    },
    {
        "q": "Match the aggregate function with its result:",
        "type": "match",
        "left": [
            "SUM",
            "AVG",
            "MIN",
            "MAX"
        ],
        "right": [
            "Total of values",
            "Mean of values",
            "Smallest value",
            "Largest value"
        ]
    },
    {
        "q": "Rearrange the GROUP BY query structure:",
        "type": "rearrange",
        "words": [
            "SELECT",
            "FROM",
            "WHERE",
            "GROUP BY",
            "HAVING"
        ]
    },
    {
        "q": "Which constraint ensures a column cannot have NULL values?",
        "type": "mcq",
        "o": [
            "NOT NULL",
            "REQUIRED",
            "MANDATORY",
            "NO_EMPTY"
        ]
    },
    {
        "q": "The _____ constraint ensures all values in a column are different.",
        "type": "fill_blank",
        "answers": [
            "UNIQUE"
        ],
        "other_options": [
            "DISTINCT",
            "DIFFERENT",
            "SINGLE"
        ]
    },
    {
        "q": "A PRIMARY KEY can contain NULL values.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this constraint check?",
        "type": "mcq",
        "c": "-- Given: age INT CHECK (age >= 0)\n-- INSERT INTO users (age) VALUES (-5);\n-- Result?",
        "o": [
            "Constraint violation error",
            "Inserts -5 successfully",
            "Inserts 0 instead",
            "Inserts NULL instead"
        ]
    },
    {
        "q": "Match the constraint with its purpose:",
        "type": "match",
        "left": [
            "PRIMARY KEY",
            "FOREIGN KEY",
            "CHECK",
            "DEFAULT"
        ],
        "right": [
            "Unique identifier",
            "References another table",
            "Validates condition",
            "Sets fallback value"
        ]
    },
    {
        "q": "Rearrange the table creation steps:",
        "type": "rearrange",
        "words": [
            "CREATE TABLE",
            "Define columns",
            "Set data types",
            "Add constraints",
            "Execute"
        ]
    },
    {
        "q": "What does the DISTINCT keyword do?",
        "type": "mcq",
        "o": [
            "Removes duplicate rows",
            "Sorts the result",
            "Filters NULL values",
            "Counts unique values"
        ]
    },
    {
        "q": "The _____ operator is used to search for a pattern.",
        "type": "fill_blank",
        "answers": [
            "LIKE"
        ],
        "other_options": [
            "MATCH",
            "PATTERN",
            "SEARCH"
        ]
    },
    {
        "q": "The % wildcard in LIKE matches any sequence of characters.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT 'Apple' LIKE 'A%';",
        "o": [
            "True (or 1)",
            "False (or 0)",
            "Apple",
            "Error"
        ]
    },
    {
        "q": "Match the wildcard with its meaning:",
        "type": "match",
        "left": [
            "%",
            "_",
            "[abc]",
            "[^abc]"
        ],
        "right": [
            "Any characters",
            "Single character",
            "Any in set",
            "Not in set"
        ]
    },
    {
        "q": "Rearrange the LIKE pattern complexity:",
        "type": "rearrange",
        "words": [
            "Exact match",
            "Starts with",
            "Ends with",
            "Contains",
            "Complex pattern"
        ]
    },
    {
        "q": "Which clause filters groups after aggregation?",
        "type": "mcq",
        "o": [
            "HAVING",
            "WHERE",
            "FILTER",
            "GROUP FILTER"
        ]
    },
    {
        "q": "The _____ keyword combines results from multiple SELECT statements.",
        "type": "fill_blank",
        "answers": [
            "UNION"
        ],
        "other_options": [
            "MERGE",
            "COMBINE",
            "JOIN"
        ]
    },
    {
        "q": "UNION removes duplicate rows by default.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT 1 UNION SELECT 1 UNION SELECT 2;",
        "o": [
            "Two rows: 1 and 2",
            "Three rows: 1, 1, 2",
            "One row: 1",
            "Error"
        ]
    },
    {
        "q": "Match the set operation with its behavior:",
        "type": "match",
        "left": [
            "UNION",
            "UNION ALL",
            "INTERSECT",
            "EXCEPT"
        ],
        "right": [
            "Unique combined",
            "All combined",
            "Common only",
            "First minus second"
        ]
    },
    {
        "q": "Rearrange the subquery complexity:",
        "type": "rearrange",
        "words": [
            "Scalar subquery",
            "Row subquery",
            "Table subquery",
            "Correlated subquery"
        ]
    },
    {
        "q": "What is a subquery?",
        "type": "mcq",
        "o": [
            "A query nested inside another query",
            "A backup query",
            "A stored procedure",
            "A view definition"
        ]
    },
    {
        "q": "The _____ keyword checks if a subquery returns any rows.",
        "type": "fill_blank",
        "answers": [
            "EXISTS"
        ],
        "other_options": [
            "HAS",
            "CONTAINS",
            "FOUND"
        ]
    },
    {
        "q": "Subqueries can be used in the SELECT clause.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT (SELECT 1 + 2) AS result;",
        "o": [
            "3",
            "1 + 2",
            "NULL",
            "Error"
        ]
    },
    {
        "q": "Match the subquery location with its term:",
        "type": "match",
        "left": [
            "SELECT clause",
            "FROM clause",
            "WHERE clause",
            "HAVING clause"
        ],
        "right": [
            "Scalar subquery",
            "Derived table",
            "Filter subquery",
            "Group filter subquery"
        ]
    },
    {
        "q": "Rearrange the NULL handling priority:",
        "type": "rearrange",
        "words": [
            "IS NULL",
            "IS NOT NULL",
            "COALESCE",
            "NULLIF",
            "IFNULL"
        ]
    },
    {
        "q": "How do you check if a value is NULL?",
        "type": "mcq",
        "o": [
            "IS NULL",
            "= NULL",
            "== NULL",
            "EQUALS NULL"
        ]
    },
    {
        "q": "The _____ function returns the first non-NULL value.",
        "type": "fill_blank",
        "answers": [
            "COALESCE"
        ],
        "other_options": [
            "FIRST",
            "IFNULL",
            "NVL"
        ]
    },
    {
        "q": "NULL = NULL evaluates to TRUE in SQL.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT COALESCE(NULL, NULL, 'default');",
        "o": [
            "default",
            "NULL",
            "Empty string",
            "Error"
        ]
    },
    {
        "q": "Match the NULL function with its behavior:",
        "type": "match",
        "left": [
            "COALESCE",
            "NULLIF",
            "ISNULL",
            "NVL"
        ],
        "right": [
            "First non-null",
            "Returns NULL if equal",
            "SQL Server null check",
            "Oracle null check"
        ]
    },
    {
        "q": "Rearrange the INSERT statement components:",
        "type": "rearrange",
        "words": [
            "INSERT INTO",
            "table_name",
            "columns",
            "VALUES",
            "data"
        ]
    },
    {
        "q": "Which statement adds new rows to a table?",
        "type": "mcq",
        "o": [
            "INSERT",
            "ADD",
            "CREATE",
            "APPEND"
        ]
    },
    {
        "q": "The _____ statement modifies existing data in a table.",
        "type": "fill_blank",
        "answers": [
            "UPDATE"
        ],
        "other_options": [
            "MODIFY",
            "CHANGE",
            "ALTER"
        ]
    },
    {
        "q": "DELETE without WHERE removes all rows from a table.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this statement?",
        "type": "mcq",
        "c": "INSERT INTO nums VALUES (1), (2), (3);\nSELECT COUNT(*) FROM nums;",
        "o": [
            "3",
            "1",
            "6",
            "Error"
        ]
    },
    {
        "q": "Match the DML command with its purpose:",
        "type": "match",
        "left": [
            "INSERT",
            "UPDATE",
            "DELETE",
            "MERGE"
        ],
        "right": [
            "Add rows",
            "Modify rows",
            "Remove rows",
            "Upsert rows"
        ]
    },
    {
        "q": "Rearrange the UPDATE statement structure:",
        "type": "rearrange",
        "words": [
            "UPDATE",
            "table_name",
            "SET",
            "column = value",
            "WHERE"
        ]
    },
    {
        "q": "What does the LIMIT clause do?",
        "type": "mcq",
        "o": [
            "Restricts the number of rows returned",
            "Limits column width",
            "Restricts query time",
            "Limits memory usage"
        ]
    },
    {
        "q": "The _____ clause skips a number of rows before returning results.",
        "type": "fill_blank",
        "answers": [
            "OFFSET"
        ],
        "other_options": [
            "SKIP",
            "START",
            "BEGIN"
        ]
    },
    {
        "q": "LIMIT and OFFSET are used for pagination.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT * FROM (SELECT 1 AS n UNION SELECT 2 UNION SELECT 3) t LIMIT 2;",
        "o": [
            "Two rows",
            "Three rows",
            "One row",
            "Error"
        ]
    },
    {
        "q": "Match the pagination term with its SQL:",
        "type": "match",
        "left": [
            "LIMIT",
            "OFFSET",
            "TOP",
            "FETCH FIRST"
        ],
        "right": [
            "Row count",
            "Skip rows",
            "SQL Server limit",
            "Standard SQL limit"
        ]
    },
    {
        "q": "Rearrange the pagination query order:",
        "type": "rearrange",
        "words": [
            "SELECT",
            "FROM",
            "ORDER BY",
            "LIMIT",
            "OFFSET"
        ]
    },
    {
        "q": "Which keyword specifies ascending sort order?",
        "type": "mcq",
        "o": [
            "ASC",
            "UP",
            "ASCENDING",
            "FORWARD"
        ]
    },
    {
        "q": "The default sort order in ORDER BY is _____.",
        "type": "fill_blank",
        "answers": [
            "ASC"
        ],
        "other_options": [
            "DESC",
            "NONE",
            "RANDOM"
        ]
    },
    {
        "q": "You can sort by multiple columns in ORDER BY.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT * FROM (SELECT 3 AS n UNION SELECT 1 UNION SELECT 2) t ORDER BY n;",
        "o": [
            "1, 2, 3",
            "3, 1, 2",
            "3, 2, 1",
            "Error"
        ]
    },
    {
        "q": "Match the ORDER BY option with its effect:",
        "type": "match",
        "left": [
            "ASC",
            "DESC",
            "NULLS FIRST",
            "NULLS LAST"
        ],
        "right": [
            "Low to high",
            "High to low",
            "NULLs at start",
            "NULLs at end"
        ]
    },
    {
        "q": "Rearrange data types by storage size (smallest first):",
        "type": "rearrange",
        "words": [
            "TINYINT",
            "SMALLINT",
            "INT",
            "BIGINT",
            "DECIMAL"
        ]
    },
    {
        "q": "Which data type stores variable-length text?",
        "type": "mcq",
        "o": [
            "VARCHAR",
            "CHAR",
            "TEXT",
            "STRING"
        ]
    },
    {
        "q": "The _____ data type stores exact decimal numbers.",
        "type": "fill_blank",
        "answers": [
            "DECIMAL"
        ],
        "other_options": [
            "FLOAT",
            "DOUBLE",
            "REAL"
        ]
    },
    {
        "q": "FLOAT stores exact numeric values.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT CAST('123' AS INTEGER) + 1;",
        "o": [
            "124",
            "1231",
            "123",
            "Error"
        ]
    },
    {
        "q": "Match the data type with its category:",
        "type": "match",
        "left": [
            "INT",
            "VARCHAR",
            "DATE",
            "BLOB"
        ],
        "right": [
            "Numeric",
            "String",
            "Temporal",
            "Binary"
        ]
    },
    {
        "q": "Rearrange the date/time types by precision:",
        "type": "rearrange",
        "words": [
            "DATE",
            "TIME",
            "DATETIME",
            "TIMESTAMP",
            "INTERVAL"
        ]
    },
    {
        "q": "What is the purpose of an alias in SQL?",
        "type": "mcq",
        "o": [
            "To give a temporary name to a table or column",
            "To create a permanent table copy",
            "To encrypt data",
            "To compress results"
        ]
    },
    {
        "q": "The _____ keyword is used to create an alias.",
        "type": "fill_blank",
        "answers": [
            "AS"
        ],
        "other_options": [
            "ALIAS",
            "NAME",
            "RENAME"
        ]
    },
    {
        "q": "Table aliases are required for self-joins.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT 1 + 1 AS result;",
        "o": [
            "Column named 'result' with value 2",
            "Column named 'AS' with value 2",
            "Error",
            "Two columns"
        ]
    },
    {
        "q": "Match the alias usage with its example:",
        "type": "match",
        "left": [
            "Column alias",
            "Table alias",
            "Subquery alias",
            "Expression alias"
        ],
        "right": [
            "SELECT name AS n",
            "FROM users u",
            "FROM (SELECT 1) t",
            "SELECT 1+1 AS sum"
        ]
    },
    {
        "q": "Rearrange the CASE expression structure:",
        "type": "rearrange",
        "words": [
            "CASE",
            "WHEN condition",
            "THEN result",
            "ELSE default",
            "END"
        ]
    },
    {
        "q": "Which expression provides conditional logic in SQL?",
        "type": "mcq",
        "o": [
            "CASE",
            "IF",
            "SWITCH",
            "WHEN"
        ]
    },
    {
        "q": "The _____ keyword specifies the default result in CASE.",
        "type": "fill_blank",
        "answers": [
            "ELSE"
        ],
        "other_options": [
            "DEFAULT",
            "OTHERWISE",
            "OTHER"
        ]
    },
    {
        "q": "CASE expressions can be nested.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT CASE WHEN 1 > 2 THEN 'A' ELSE 'B' END;",
        "o": [
            "B",
            "A",
            "NULL",
            "Error"
        ]
    },
    {
        "q": "Match the conditional function with its database:",
        "type": "match",
        "left": [
            "CASE",
            "IF()",
            "IIF()",
            "DECODE()"
        ],
        "right": [
            "Standard SQL",
            "MySQL",
            "SQL Server",
            "Oracle"
        ]
    },
    {
        "q": "Rearrange the comparison operators by precedence:",
        "type": "rearrange",
        "words": [
            "=",
            "!=",
            "<",
            ">",
            "BETWEEN"
        ]
    },
    {
        "q": "Which operator checks if a value is within a range?",
        "type": "mcq",
        "o": [
            "BETWEEN",
            "RANGE",
            "IN",
            "WITHIN"
        ]
    },
    {
        "q": "The _____ operator checks if a value exists in a list.",
        "type": "fill_blank",
        "answers": [
            "IN"
        ],
        "other_options": [
            "EXISTS",
            "ANY",
            "CONTAINS"
        ]
    },
    {
        "q": "BETWEEN includes both boundary values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT 5 BETWEEN 1 AND 10;",
        "o": [
            "True (or 1)",
            "False (or 0)",
            "5",
            "Error"
        ]
    },
    {
        "q": "Match the operator with its check:",
        "type": "match",
        "left": [
            "BETWEEN",
            "IN",
            "LIKE",
            "IS NULL"
        ],
        "right": [
            "Range check",
            "List membership",
            "Pattern match",
            "Null check"
        ]
    },
    {
        "q": "Rearrange the logical operators by precedence:",
        "type": "rearrange",
        "words": [
            "NOT",
            "AND",
            "OR",
            "XOR"
        ]
    },
    {
        "q": "Which operator returns TRUE if both conditions are TRUE?",
        "type": "mcq",
        "o": [
            "AND",
            "OR",
            "NOT",
            "XOR"
        ]
    },
    {
        "q": "The _____ operator negates a boolean condition.",
        "type": "fill_blank",
        "answers": [
            "NOT"
        ],
        "other_options": [
            "NEGATE",
            "REVERSE",
            "INVERT"
        ]
    },
    {
        "q": "AND has higher precedence than OR in SQL.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT 1 WHERE 1=1 AND 2=2;",
        "o": [
            "1",
            "0",
            "NULL",
            "No rows"
        ]
    },
    {
        "q": "What is a LEFT JOIN?",
        "type": "mcq",
        "o": [
            "Returns all rows from left table with matched right rows",
            "Returns only matched rows",
            "Returns all rows from right table",
            "Returns cartesian product"
        ]
    },
    {
        "q": "The _____ join returns all rows from the right table.",
        "type": "fill_blank",
        "answers": [
            "RIGHT"
        ],
        "other_options": [
            "LEFT",
            "FULL",
            "CROSS"
        ]
    },
    {
        "q": "LEFT JOIN and LEFT OUTER JOIN are the same.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this join?",
        "type": "mcq",
        "c": "-- t1: (1), (2)\n-- t2: (2), (3)\nSELECT COUNT(*) FROM t1 LEFT JOIN t2 ON t1.id = t2.id;",
        "o": [
            "2",
            "1",
            "3",
            "4"
        ]
    },
    {
        "q": "Match the join with its NULL behavior:",
        "type": "match",
        "left": [
            "INNER JOIN",
            "LEFT JOIN",
            "RIGHT JOIN",
            "CROSS JOIN"
        ],
        "right": [
            "No NULLs from join",
            "NULLs for unmatched right",
            "NULLs for unmatched left",
            "No ON clause needed"
        ]
    },
    {
        "q": "Rearrange the join types by result size (smallest first):",
        "type": "rearrange",
        "words": [
            "INNER JOIN",
            "LEFT JOIN",
            "FULL JOIN",
            "CROSS JOIN"
        ]
    },
    {
        "q": "What is a CROSS JOIN?",
        "type": "mcq",
        "o": [
            "Cartesian product of two tables",
            "Join with equality condition",
            "Join without conditions",
            "Join on multiple columns"
        ]
    },
    {
        "q": "A self-join joins a table to _____.",
        "type": "fill_blank",
        "answers": [
            "itself"
        ],
        "other_options": [
            "another table",
            "a view",
            "a subquery"
        ]
    },
    {
        "q": "CROSS JOIN requires an ON clause.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this CROSS JOIN?",
        "type": "mcq",
        "c": "-- t1 has 3 rows, t2 has 4 rows\nSELECT COUNT(*) FROM t1 CROSS JOIN t2;",
        "o": [
            "12",
            "7",
            "3",
            "4"
        ]
    },
    {
        "q": "Match the join term with its definition:",
        "type": "match",
        "left": [
            "Self-join",
            "Natural join",
            "Cross join",
            "Equi-join"
        ],
        "right": [
            "Table to itself",
            "Join on same column names",
            "Cartesian product",
            "Join with = operator"
        ]
    },
    {
        "q": "Rearrange the aggregation functions by complexity:",
        "type": "rearrange",
        "words": [
            "COUNT",
            "SUM",
            "AVG",
            "STDDEV",
            "VARIANCE"
        ]
    },
    {
        "q": "What is the difference between COUNT(*) and COUNT(column)?",
        "type": "mcq",
        "o": [
            "COUNT(*) counts all rows, COUNT(column) excludes NULLs",
            "They are identical",
            "COUNT(*) is faster",
            "COUNT(column) counts all rows"
        ]
    },
    {
        "q": "The _____ function returns the total of all values.",
        "type": "fill_blank",
        "answers": [
            "SUM"
        ],
        "other_options": [
            "TOTAL",
            "ADD",
            "AGGREGATE"
        ]
    },
    {
        "q": "AVG ignores NULL values in calculations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT AVG(value) FROM (SELECT 10 AS value UNION ALL SELECT 20 UNION ALL SELECT NULL) t;",
        "o": [
            "15",
            "10",
            "30",
            "NULL"
        ]
    },
    {
        "q": "Match the aggregate function with its NULL handling:",
        "type": "match",
        "left": [
            "COUNT(*)",
            "COUNT(col)",
            "SUM(col)",
            "AVG(col)"
        ],
        "right": [
            "Includes NULL rows",
            "Excludes NULLs",
            "Ignores NULLs",
            "Ignores NULLs in avg"
        ]
    },
    {
        "q": "Rearrange the GROUP BY query parts:",
        "type": "rearrange",
        "words": [
            "SELECT columns",
            "FROM table",
            "WHERE filter",
            "GROUP BY",
            "HAVING"
        ]
    },
    {
        "q": "What is the purpose of the HAVING clause?",
        "type": "mcq",
        "o": [
            "Filter groups after aggregation",
            "Filter rows before aggregation",
            "Sort aggregated results",
            "Define grouping columns"
        ]
    },
    {
        "q": "The _____ clause must come before GROUP BY.",
        "type": "fill_blank",
        "answers": [
            "WHERE"
        ],
        "other_options": [
            "HAVING",
            "ORDER BY",
            "LIMIT"
        ]
    },
    {
        "q": "You cannot use aggregate functions in WHERE clause.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT dept, COUNT(*) FROM emp GROUP BY dept HAVING COUNT(*) > 5;",
        "o": [
            "Departments with more than 5 employees",
            "All departments",
            "First 5 departments",
            "Error"
        ]
    },
    {
        "q": "Match the clause with its filter timing:",
        "type": "match",
        "left": [
            "WHERE",
            "HAVING",
            "ON",
            "LIMIT"
        ],
        "right": [
            "Before grouping",
            "After grouping",
            "During join",
            "After sorting"
        ]
    },
    {
        "q": "Rearrange the subquery types by complexity:",
        "type": "rearrange",
        "words": [
            "Scalar subquery",
            "Column subquery",
            "Row subquery",
            "Table subquery",
            "Correlated subquery"
        ]
    },
    {
        "q": "What is a scalar subquery?",
        "type": "mcq",
        "o": [
            "A subquery that returns a single value",
            "A subquery that returns multiple rows",
            "A subquery with joins",
            "A subquery with aggregates"
        ]
    },
    {
        "q": "The _____ keyword checks if a subquery returns any results.",
        "type": "fill_blank",
        "answers": [
            "EXISTS"
        ],
        "other_options": [
            "IN",
            "ANY",
            "SOME"
        ]
    },
    {
        "q": "A correlated subquery references the outer query.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT * FROM emp WHERE salary > (SELECT AVG(salary) FROM emp);",
        "o": [
            "Employees with above-average salary",
            "All employees",
            "Average salary only",
            "Error"
        ]
    },
    {
        "q": "Match the subquery keyword with its purpose:",
        "type": "match",
        "left": [
            "IN",
            "EXISTS",
            "ANY",
            "ALL"
        ],
        "right": [
            "Match in list",
            "Check existence",
            "Match any value",
            "Match all values"
        ]
    },
    {
        "q": "Rearrange the constraint types by strictness:",
        "type": "rearrange",
        "words": [
            "DEFAULT",
            "NOT NULL",
            "UNIQUE",
            "PRIMARY KEY",
            "FOREIGN KEY"
        ]
    },
    {
        "q": "What constraint links two tables together?",
        "type": "mcq",
        "o": [
            "FOREIGN KEY",
            "PRIMARY KEY",
            "UNIQUE",
            "LINK"
        ]
    },
    {
        "q": "The _____ constraint ensures a column combination is unique.",
        "type": "fill_blank",
        "answers": [
            "UNIQUE"
        ],
        "other_options": [
            "PRIMARY KEY",
            "DISTINCT",
            "DIFFERENT"
        ]
    },
    {
        "q": "A table can have multiple PRIMARY KEY constraints.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this constraint?",
        "type": "mcq",
        "c": "CREATE TABLE t (id INT PRIMARY KEY, name VARCHAR(50));\nINSERT INTO t VALUES (1, 'A');\nINSERT INTO t VALUES (1, 'B');",
        "o": [
            "Second insert fails",
            "Both inserts succeed",
            "First insert fails",
            "Table creation fails"
        ]
    },
    {
        "q": "Match the constraint with its enforcement:",
        "type": "match",
        "left": [
            "NOT NULL",
            "UNIQUE",
            "CHECK",
            "FOREIGN KEY"
        ],
        "right": [
            "Disallows NULL",
            "Disallows duplicates",
            "Validates condition",
            "Validates reference"
        ]
    },
    {
        "q": "Rearrange the referential action options:",
        "type": "rearrange",
        "words": [
            "NO ACTION",
            "RESTRICT",
            "CASCADE",
            "SET NULL",
            "SET DEFAULT"
        ]
    },
    {
        "q": "What does ON DELETE CASCADE do?",
        "type": "mcq",
        "o": [
            "Deletes child rows when parent is deleted",
            "Prevents parent deletion",
            "Sets child values to NULL",
            "Ignores the deletion"
        ]
    },
    {
        "q": "The _____ action sets foreign key to NULL on parent deletion.",
        "type": "fill_blank",
        "answers": [
            "SET NULL"
        ],
        "other_options": [
            "CASCADE",
            "RESTRICT",
            "NO ACTION"
        ]
    },
    {
        "q": "RESTRICT and NO ACTION behave identically in most databases.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this referential action?",
        "type": "mcq",
        "c": "-- parent: (1, 'A')\n-- child references parent with ON DELETE CASCADE\n-- DELETE FROM parent WHERE id = 1;",
        "o": [
            "Child rows also deleted",
            "Delete fails",
            "Child rows unchanged",
            "Child rows set to NULL"
        ]
    },
    {
        "q": "Match the data type with its storage:",
        "type": "match",
        "left": [
            "CHAR(10)",
            "VARCHAR(10)",
            "TEXT",
            "BLOB"
        ],
        "right": [
            "Fixed 10 bytes",
            "Up to 10 characters",
            "Variable large text",
            "Binary data"
        ]
    },
    {
        "q": "Rearrange the numeric types by precision:",
        "type": "rearrange",
        "words": [
            "INTEGER",
            "FLOAT",
            "DOUBLE",
            "DECIMAL",
            "NUMERIC"
        ]
    },
    {
        "q": "What is the difference between CHAR and VARCHAR?",
        "type": "mcq",
        "o": [
            "CHAR is fixed-length, VARCHAR is variable-length",
            "CHAR stores numbers, VARCHAR stores text",
            "CHAR is faster for all operations",
            "There is no difference"
        ]
    },
    {
        "q": "The _____ data type stores date and time together.",
        "type": "fill_blank",
        "answers": [
            "DATETIME"
        ],
        "other_options": [
            "DATE",
            "TIME",
            "TIMESTAMP"
        ]
    },
    {
        "q": "DECIMAL and NUMERIC are the same in most databases.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this date function?",
        "type": "mcq",
        "c": "SELECT EXTRACT(YEAR FROM DATE '2024-06-15');",
        "o": [
            "2024",
            "6",
            "15",
            "Error"
        ]
    },
    {
        "q": "Match the date function with its return:",
        "type": "match",
        "left": [
            "CURRENT_DATE",
            "CURRENT_TIME",
            "CURRENT_TIMESTAMP",
            "EXTRACT"
        ],
        "right": [
            "Today's date",
            "Current time",
            "Date and time",
            "Part of date"
        ]
    },
    {
        "q": "Rearrange the string functions by common usage:",
        "type": "rearrange",
        "words": [
            "CONCAT",
            "SUBSTRING",
            "TRIM",
            "UPPER",
            "REPLACE"
        ]
    },
    {
        "q": "Which function combines two strings?",
        "type": "mcq",
        "o": [
            "CONCAT",
            "JOIN",
            "MERGE",
            "COMBINE"
        ]
    },
    {
        "q": "The _____ function removes leading and trailing spaces.",
        "type": "fill_blank",
        "answers": [
            "TRIM"
        ],
        "other_options": [
            "STRIP",
            "CLEAN",
            "CUT"
        ]
    },
    {
        "q": "UPPER function converts text to uppercase.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT LENGTH('Hello World');",
        "o": [
            "11",
            "10",
            "12",
            "Error"
        ]
    },
    {
        "q": "Match the string function with its result:",
        "type": "match",
        "left": [
            "UPPER('abc')",
            "LOWER('ABC')",
            "LENGTH('test')",
            "TRIM(' hi ')"
        ],
        "right": [
            "ABC",
            "abc",
            "4",
            "hi"
        ]
    },
    {
        "q": "Rearrange the math functions by complexity:",
        "type": "rearrange",
        "words": [
            "ABS",
            "ROUND",
            "FLOOR",
            "CEILING",
            "POWER"
        ]
    },
    {
        "q": "Which function returns the absolute value?",
        "type": "mcq",
        "o": [
            "ABS",
            "ABSOLUTE",
            "POSITIVE",
            "VALUE"
        ]
    },
    {
        "q": "The _____ function rounds a number to an integer toward zero.",
        "type": "fill_blank",
        "answers": [
            "TRUNCATE"
        ],
        "other_options": [
            "ROUND",
            "FLOOR",
            "CEILING"
        ]
    },
    {
        "q": "FLOOR(-2.5) returns -3.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "SELECT ROUND(3.567, 2);",
        "o": [
            "3.57",
            "3.56",
            "4",
            "Error"
        ]
    },
    {
        "q": "Match the math function with its result:",
        "type": "match",
        "left": [
            "ABS(-5)",
            "CEILING(2.1)",
            "FLOOR(2.9)",
            "ROUND(2.5)"
        ],
        "right": [
            "5",
            "3",
            "2",
            "3"
        ]
    },
    {
        "q": "Rearrange the DDL commands by lifecycle:",
        "type": "rearrange",
        "words": [
            "CREATE",
            "ALTER",
            "TRUNCATE",
            "DROP"
        ]
    },
    {
        "q": "Which command modifies a table structure?",
        "type": "mcq",
        "o": [
            "ALTER",
            "MODIFY",
            "CHANGE",
            "UPDATE"
        ]
    },
    {
        "q": "The _____ command removes all rows but keeps the table structure.",
        "type": "fill_blank",
        "answers": [
            "TRUNCATE"
        ],
        "other_options": [
            "DELETE",
            "DROP",
            "CLEAR"
        ]
    },
    {
        "q": "DROP TABLE can be rolled back in a transaction.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this DDL statement?",
        "type": "mcq",
        "c": "ALTER TABLE users ADD email VARCHAR(100);",
        "o": [
            "Adds email column to users table",
            "Creates new table",
            "Deletes email column",
            "Error"
        ]
    },
    {
        "q": "Match the DDL command with its action:",
        "type": "match",
        "left": [
            "CREATE",
            "ALTER",
            "DROP",
            "TRUNCATE"
        ],
        "right": [
            "Creates object",
            "Modifies structure",
            "Removes object",
            "Removes all data"
        ]
    },
    {
        "q": "Rearrange the view creation steps:",
        "type": "rearrange",
        "words": [
            "CREATE VIEW",
            "view_name",
            "AS",
            "SELECT statement"
        ]
    },
    {
        "q": "What is a view in SQL?",
        "type": "mcq",
        "o": [
            "A virtual table based on a SELECT query",
            "A copy of a table",
            "A type of index",
            "A stored procedure"
        ]
    },
    {
        "q": "The _____ keyword allows updating through a view.",
        "type": "fill_blank",
        "answers": [
            "WITH CHECK OPTION"
        ],
        "other_options": [
            "UPDATABLE",
            "MODIFIABLE",
            "WRITABLE"
        ]
    },
    {
        "q": "Views store data like tables.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this view query?",
        "type": "mcq",
        "c": "CREATE VIEW active_users AS SELECT * FROM users WHERE status = 'active';\nSELECT COUNT(*) FROM active_users;",
        "o": [
            "Count of active users",
            "Count of all users",
            "View definition",
            "Error"
        ]
    },
    {
        "q": "Match the view type with its characteristic:",
        "type": "match",
        "left": [
            "Simple view",
            "Complex view",
            "Materialized view",
            "Inline view"
        ],
        "right": [
            "Single table, updatable",
            "Joins, may not update",
            "Stores data",
            "Subquery in FROM"
        ]
    },
    {
        "q": "What is a window function in SQL?",
        "type": "mcq",
        "o": [
            "A function that performs calculations across rows related to current row",
            "A function that creates pop-up windows",
            "A function that splits data into windows",
            "A function that filters rows"
        ]
    },
    {
        "q": "The _____ clause defines the window for a window function.",
        "type": "fill_blank",
        "answers": [
            "OVER"
        ],
        "other_options": [
            "WINDOW",
            "PARTITION",
            "FRAME"
        ]
    },
    {
        "q": "Window functions can be used in the WHERE clause.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this window function?",
        "type": "mcq",
        "c": "SELECT name, ROW_NUMBER() OVER (ORDER BY salary DESC) as rank\nFROM employees LIMIT 1;",
        "o": [
            "Name with rank 1 (highest salary)",
            "Name with rank 1 (lowest salary)",
            "All names with ranks",
            "Error"
        ]
    },
    {
        "q": "Match the window function with its purpose:",
        "type": "match",
        "left": [
            "ROW_NUMBER()",
            "RANK()",
            "DENSE_RANK()",
            "NTILE()"
        ],
        "right": [
            "Unique sequential numbers",
            "Ranks with gaps",
            "Ranks without gaps",
            "Divides into buckets"
        ]
    },
    {
        "q": "Rearrange the window function clauses:",
        "type": "rearrange",
        "words": [
            "Function name",
            "OVER",
            "PARTITION BY",
            "ORDER BY",
            "Frame clause"
        ]
    },
    {
        "q": "What does PARTITION BY do in a window function?",
        "type": "mcq",
        "o": [
            "Divides rows into groups for separate calculations",
            "Sorts the result set",
            "Filters the rows",
            "Joins tables together"
        ]
    },
    {
        "q": "The _____ function returns the value from the previous row.",
        "type": "fill_blank",
        "answers": [
            "LAG"
        ],
        "other_options": [
            "LEAD",
            "PREV",
            "BEFORE"
        ]
    },
    {
        "q": "LEAD function accesses a following row.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this LAG function?",
        "type": "mcq",
        "c": "SELECT name, salary, LAG(salary, 1, 0) OVER (ORDER BY hire_date)\nFROM employees WHERE id = 1;",
        "o": [
            "Current salary and previous salary (or 0 if first)",
            "Current and next salary",
            "Only current salary",
            "Error"
        ]
    },
    {
        "q": "Match the navigation function with its behavior:",
        "type": "match",
        "left": [
            "LAG",
            "LEAD",
            "FIRST_VALUE",
            "LAST_VALUE"
        ],
        "right": [
            "Previous row",
            "Next row",
            "First in partition",
            "Last in partition"
        ]
    },
    {
        "q": "Rearrange the ranking functions by their gap behavior:",
        "type": "rearrange",
        "words": [
            "ROW_NUMBER",
            "DENSE_RANK",
            "RANK",
            "PERCENT_RANK",
            "CUME_DIST"
        ]
    },
    {
        "q": "What is a CTE (Common Table Expression)?",
        "type": "mcq",
        "o": [
            "A temporary named result set defined in the query",
            "A permanent table",
            "A stored procedure",
            "A database trigger"
        ]
    },
    {
        "q": "The _____ keyword introduces a CTE.",
        "type": "fill_blank",
        "answers": [
            "WITH"
        ],
        "other_options": [
            "CTE",
            "DEFINE",
            "AS"
        ]
    },
    {
        "q": "CTEs can be recursive.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this CTE?",
        "type": "mcq",
        "c": "WITH nums AS (SELECT 1 AS n UNION ALL SELECT 2)\nSELECT SUM(n) FROM nums;",
        "o": [
            "3",
            "1",
            "2",
            "Error"
        ]
    },
    {
        "q": "Match the CTE term with its definition:",
        "type": "match",
        "left": [
            "WITH clause",
            "CTE name",
            "AS keyword",
            "Anchor member"
        ],
        "right": [
            "Starts CTE definition",
            "Names the result set",
            "Introduces query",
            "Base case in recursive"
        ]
    },
    {
        "q": "Rearrange the recursive CTE structure:",
        "type": "rearrange",
        "words": [
            "WITH RECURSIVE",
            "CTE name",
            "AS",
            "Anchor query",
            "UNION ALL",
            "Recursive query"
        ]
    },
    {
        "q": "What is the purpose of an index in SQL?",
        "type": "mcq",
        "o": [
            "To speed up data retrieval",
            "To store data in sorted order",
            "To enforce constraints",
            "To backup data"
        ]
    },
    {
        "q": "The _____ index is automatically created for primary keys.",
        "type": "fill_blank",
        "answers": [
            "clustered"
        ],
        "other_options": [
            "non-clustered",
            "unique",
            "composite"
        ]
    },
    {
        "q": "Too many indexes can slow down INSERT operations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this index creation?",
        "type": "mcq",
        "c": "CREATE INDEX idx_name ON employees(last_name);\nSELECT * FROM employees WHERE last_name = 'Smith';",
        "o": [
            "Query uses index for faster lookup",
            "Query scans full table",
            "Index creation fails",
            "Error"
        ]
    },
    {
        "q": "Match the index type with its use case:",
        "type": "match",
        "left": [
            "B-tree index",
            "Hash index",
            "Full-text index",
            "Spatial index"
        ],
        "right": [
            "Range queries",
            "Equality lookups",
            "Text search",
            "Geographic data"
        ]
    },
    {
        "q": "Rearrange the index creation steps:",
        "type": "rearrange",
        "words": [
            "Identify slow queries",
            "Choose columns",
            "Create index",
            "Test performance",
            "Monitor usage"
        ]
    },
    {
        "q": "What is a composite index?",
        "type": "mcq",
        "o": [
            "An index on multiple columns",
            "An index on a single column",
            "An index with multiple values",
            "A merged index"
        ]
    },
    {
        "q": "The _____ of columns in a composite index affects query performance.",
        "type": "fill_blank",
        "answers": [
            "order"
        ],
        "other_options": [
            "count",
            "type",
            "size"
        ]
    },
    {
        "q": "A covering index includes all columns needed by a query.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query?",
        "type": "mcq",
        "c": "-- Index on (last_name, first_name)\nSELECT * FROM emp WHERE first_name = 'John';",
        "o": [
            "May not use the index efficiently",
            "Uses index fully",
            "Error",
            "Returns no rows"
        ]
    },
    {
        "q": "Match the index strategy with its benefit:",
        "type": "match",
        "left": [
            "Covering index",
            "Partial index",
            "Unique index",
            "Clustered index"
        ],
        "right": [
            "Avoids table lookup",
            "Indexes subset of rows",
            "Enforces uniqueness",
            "Determines row order"
        ]
    },
    {
        "q": "Rearrange the query optimization steps:",
        "type": "rearrange",
        "words": [
            "Analyze query",
            "Check execution plan",
            "Add indexes",
            "Rewrite query",
            "Test performance"
        ]
    },
    {
        "q": "What is a stored procedure?",
        "type": "mcq",
        "o": [
            "A saved SQL program that can be executed repeatedly",
            "A temporary table",
            "A backup copy of data",
            "A database trigger"
        ]
    },
    {
        "q": "The _____ statement calls a stored procedure.",
        "type": "fill_blank",
        "answers": [
            "CALL"
        ],
        "other_options": [
            "EXECUTE",
            "RUN",
            "INVOKE"
        ]
    },
    {
        "q": "Stored procedures can have input and output parameters.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this procedure?",
        "type": "mcq",
        "c": "CREATE PROCEDURE get_count()\nBEGIN\n  SELECT COUNT(*) FROM users;\nEND;\nCALL get_count();",
        "o": [
            "Returns count of users",
            "Creates a table",
            "Deletes all users",
            "Error"
        ]
    },
    {
        "q": "Match the procedure element with its purpose:",
        "type": "match",
        "left": [
            "IN parameter",
            "OUT parameter",
            "INOUT parameter",
            "RETURN"
        ],
        "right": [
            "Input value",
            "Output value",
            "Both input and output",
            "Exits procedure"
        ]
    },
    {
        "q": "Rearrange the stored procedure lifecycle:",
        "type": "rearrange",
        "words": [
            "CREATE PROCEDURE",
            "Define parameters",
            "Write body",
            "Call procedure",
            "Drop procedure"
        ]
    },
    {
        "q": "What is a database trigger?",
        "type": "mcq",
        "o": [
            "Code that executes automatically on table events",
            "A manual procedure call",
            "A scheduled backup",
            "A query optimizer"
        ]
    },
    {
        "q": "The _____ trigger fires before the data modification.",
        "type": "fill_blank",
        "answers": [
            "BEFORE"
        ],
        "other_options": [
            "AFTER",
            "INSTEAD OF",
            "ON"
        ]
    },
    {
        "q": "Triggers can prevent data modifications.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this trigger?",
        "type": "mcq",
        "c": "CREATE TRIGGER audit_insert\nAFTER INSERT ON orders\nFOR EACH ROW\nINSERT INTO audit_log VALUES (NEW.id, NOW());",
        "o": [
            "Logs each new order to audit table",
            "Deletes the inserted order",
            "Updates the order",
            "Error"
        ]
    },
    {
        "q": "Match the trigger timing with its use case:",
        "type": "match",
        "left": [
            "BEFORE INSERT",
            "AFTER INSERT",
            "BEFORE DELETE",
            "AFTER UPDATE"
        ],
        "right": [
            "Validate data",
            "Log creation",
            "Prevent deletion",
            "Track changes"
        ]
    },
    {
        "q": "Rearrange the trigger execution flow:",
        "type": "rearrange",
        "words": [
            "Event occurs",
            "Trigger fires",
            "Check condition",
            "Execute action",
            "Complete operation"
        ]
    },
    {
        "q": "What is a transaction in SQL?",
        "type": "mcq",
        "o": [
            "A unit of work that is atomic and consistent",
            "A single SQL statement",
            "A database backup",
            "A connection session"
        ]
    },
    {
        "q": "The _____ statement saves all changes made in a transaction.",
        "type": "fill_blank",
        "answers": [
            "COMMIT"
        ],
        "other_options": [
            "SAVE",
            "APPLY",
            "CONFIRM"
        ]
    },
    {
        "q": "ROLLBACK undoes all changes since the last COMMIT.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this transaction?",
        "type": "mcq",
        "c": "BEGIN TRANSACTION;\nINSERT INTO accounts VALUES (1, 1000);\nROLLBACK;\nSELECT COUNT(*) FROM accounts;",
        "o": [
            "0 (insert was rolled back)",
            "1 (insert succeeded)",
            "Error",
            "NULL"
        ]
    },
    {
        "q": "Match the ACID property with its meaning:",
        "type": "match",
        "left": [
            "Atomicity",
            "Consistency",
            "Isolation",
            "Durability"
        ],
        "right": [
            "All or nothing",
            "Valid state",
            "Concurrent safety",
            "Survives failures"
        ]
    },
    {
        "q": "Rearrange the transaction workflow:",
        "type": "rearrange",
        "words": [
            "BEGIN",
            "Execute statements",
            "Validate results",
            "COMMIT or ROLLBACK"
        ]
    },
    {
        "q": "What is a savepoint?",
        "type": "mcq",
        "o": [
            "A point within a transaction to which you can rollback",
            "A backup of the database",
            "A commit point",
            "A transaction log entry"
        ]
    },
    {
        "q": "The _____ statement creates a savepoint.",
        "type": "fill_blank",
        "answers": [
            "SAVEPOINT"
        ],
        "other_options": [
            "SAVE",
            "MARK",
            "CHECKPOINT"
        ]
    },
    {
        "q": "You can have multiple savepoints in a single transaction.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this savepoint usage?",
        "type": "mcq",
        "c": "BEGIN;\nINSERT INTO t VALUES (1);\nSAVEPOINT sp1;\nINSERT INTO t VALUES (2);\nROLLBACK TO sp1;\nCOMMIT;\nSELECT COUNT(*) FROM t;",
        "o": [
            "1",
            "2",
            "0",
            "Error"
        ]
    },
    {
        "q": "Match the transaction command with its action:",
        "type": "match",
        "left": [
            "BEGIN",
            "COMMIT",
            "ROLLBACK",
            "SAVEPOINT"
        ],
        "right": [
            "Starts transaction",
            "Saves changes",
            "Undoes changes",
            "Creates restore point"
        ]
    },
    {
        "q": "Rearrange the isolation levels by strictness:",
        "type": "rearrange",
        "words": [
            "READ UNCOMMITTED",
            "READ COMMITTED",
            "REPEATABLE READ",
            "SERIALIZABLE"
        ]
    },
    {
        "q": "What is a deadlock?",
        "type": "mcq",
        "o": [
            "Two transactions waiting for each other's locks",
            "A failed transaction",
            "A corrupted table",
            "A network timeout"
        ]
    },
    {
        "q": "The _____ isolation level prevents dirty reads.",
        "type": "fill_blank",
        "answers": [
            "READ COMMITTED"
        ],
        "other_options": [
            "READ UNCOMMITTED",
            "REPEATABLE READ",
            "SERIALIZABLE"
        ]
    },
    {
        "q": "SERIALIZABLE is the strictest isolation level.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this isolation test?",
        "type": "mcq",
        "c": "-- Session 1: BEGIN; UPDATE accounts SET balance = 500 WHERE id = 1;\n-- Session 2: SELECT balance FROM accounts WHERE id = 1; (READ COMMITTED)",
        "o": [
            "Session 2 sees old value until Session 1 commits",
            "Session 2 sees 500 immediately",
            "Session 2 is blocked",
            "Error"
        ]
    },
    {
        "q": "Match the isolation issue with its description:",
        "type": "match",
        "left": [
            "Dirty read",
            "Non-repeatable read",
            "Phantom read",
            "Lost update"
        ],
        "right": [
            "Reading uncommitted data",
            "Value changes between reads",
            "New rows appear",
            "Concurrent update overwrites"
        ]
    },
    {
        "q": "Rearrange the lock types by scope:",
        "type": "rearrange",
        "words": [
            "Row lock",
            "Page lock",
            "Table lock",
            "Database lock"
        ]
    },
    {
        "q": "What does SELECT FOR UPDATE do?",
        "type": "mcq",
        "o": [
            "Locks selected rows for update",
            "Updates the selected rows",
            "Selects rows that were updated",
            "Creates a temporary table"
        ]
    },
    {
        "q": "The _____ lock allows multiple readers but blocks writers.",
        "type": "fill_blank",
        "answers": [
            "shared"
        ],
        "other_options": [
            "exclusive",
            "intent",
            "update"
        ]
    },
    {
        "q": "Exclusive locks prevent all concurrent access.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this locking query?",
        "type": "mcq",
        "c": "BEGIN;\nSELECT * FROM products WHERE id = 1 FOR UPDATE;\n-- Another session tries to update the same row",
        "o": [
            "Other session waits until lock is released",
            "Other session updates immediately",
            "First session fails",
            "Deadlock occurs"
        ]
    },
    {
        "q": "Match the lock type with its permission:",
        "type": "match",
        "left": [
            "Shared lock",
            "Exclusive lock",
            "Intent shared",
            "Intent exclusive"
        ],
        "right": [
            "Read only",
            "Read and write",
            "Plans to get shared",
            "Plans to get exclusive"
        ]
    },
    {
        "q": "Rearrange the normalization forms:",
        "type": "rearrange",
        "words": [
            "1NF",
            "2NF",
            "3NF",
            "BCNF",
            "4NF"
        ]
    },
    {
        "q": "What is First Normal Form (1NF)?",
        "type": "mcq",
        "o": [
            "Each column contains atomic values",
            "No partial dependencies",
            "No transitive dependencies",
            "Every determinant is a key"
        ]
    },
    {
        "q": "The _____ Normal Form eliminates partial dependencies.",
        "type": "fill_blank",
        "answers": [
            "Second"
        ],
        "other_options": [
            "First",
            "Third",
            "Fourth"
        ]
    },
    {
        "q": "3NF eliminates transitive dependencies.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this normalization check?",
        "type": "mcq",
        "c": "-- Table: (student_id, course_id, student_name, course_name)\n-- Is this table in 2NF?",
        "o": [
            "No, student_name depends only on student_id",
            "Yes, it is in 2NF",
            "No, it has no primary key",
            "Cannot be determined"
        ]
    },
    {
        "q": "Match the normal form with its requirement:",
        "type": "match",
        "left": [
            "1NF",
            "2NF",
            "3NF",
            "BCNF"
        ],
        "right": [
            "Atomic values",
            "Full functional dependency",
            "No transitive dependency",
            "Every determinant is key"
        ]
    },
    {
        "q": "Rearrange the schema design process:",
        "type": "rearrange",
        "words": [
            "Requirements",
            "Conceptual design",
            "Logical design",
            "Physical design",
            "Implementation"
        ]
    },
    {
        "q": "What is denormalization?",
        "type": "mcq",
        "o": [
            "Intentionally adding redundancy to improve read performance",
            "Removing all redundancy",
            "Converting to 1NF",
            "Dropping indexes"
        ]
    },
    {
        "q": "The _____ model represents entities and relationships.",
        "type": "fill_blank",
        "answers": [
            "ER"
        ],
        "other_options": [
            "SQL",
            "Data",
            "Schema"
        ]
    },
    {
        "q": "Denormalization can improve query performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this ER relationship?",
        "type": "mcq",
        "c": "-- Entity: Customer (1) -- Places -- (M) Order\n-- What is the cardinality?",
        "o": [
            "One-to-Many",
            "Many-to-Many",
            "One-to-One",
            "Cannot determine"
        ]
    },
    {
        "q": "Match the ER component with its symbol:",
        "type": "match",
        "left": [
            "Entity",
            "Attribute",
            "Relationship",
            "Primary key"
        ],
        "right": [
            "Rectangle",
            "Oval",
            "Diamond",
            "Underlined attribute"
        ]
    },
    {
        "q": "Rearrange the data integrity types:",
        "type": "rearrange",
        "words": [
            "Entity integrity",
            "Domain integrity",
            "Referential integrity",
            "User-defined integrity"
        ]
    },
    {
        "q": "What enforces referential integrity?",
        "type": "mcq",
        "o": [
            "Foreign key constraints",
            "Primary key constraints",
            "Unique constraints",
            "Check constraints"
        ]
    },
    {
        "q": "The _____ integrity ensures valid values in columns.",
        "type": "fill_blank",
        "answers": [
            "domain"
        ],
        "other_options": [
            "entity",
            "referential",
            "user"
        ]
    },
    {
        "q": "Entity integrity requires non-NULL primary keys.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this integrity check?",
        "type": "mcq",
        "c": "-- Child table references parent with FOREIGN KEY\n-- INSERT INTO child (parent_id) VALUES (999);\n-- Parent with id=999 does not exist",
        "o": [
            "Insert fails due to referential integrity",
            "Insert succeeds",
            "Inserts NULL instead",
            "Creates parent row automatically"
        ]
    },
    {
        "q": "Match the integrity type with its enforcer:",
        "type": "match",
        "left": [
            "Entity integrity",
            "Domain integrity",
            "Referential integrity",
            "Business rules"
        ],
        "right": [
            "PRIMARY KEY",
            "CHECK constraint",
            "FOREIGN KEY",
            "Triggers"
        ]
    },
    {
        "q": "What is an execution plan in SQL?",
        "type": "mcq",
        "o": [
            "A detailed breakdown of how the query will be executed",
            "A backup schedule",
            "A list of all tables",
            "A stored procedure"
        ]
    },
    {
        "q": "The _____ command shows the execution plan in many databases.",
        "type": "fill_blank",
        "answers": [
            "EXPLAIN"
        ],
        "other_options": [
            "SHOW",
            "DESCRIBE",
            "ANALYZE"
        ]
    },
    {
        "q": "A full table scan is always slower than an index scan.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this EXPLAIN query?",
        "type": "mcq",
        "c": "EXPLAIN SELECT * FROM users WHERE id = 1;",
        "o": [
            "Shows query execution plan with cost estimates",
            "Returns user data",
            "Creates an index",
            "Error"
        ]
    },
    {
        "q": "Match the execution plan term with its meaning:",
        "type": "match",
        "left": [
            "Seq Scan",
            "Index Scan",
            "Nested Loop",
            "Hash Join"
        ],
        "right": [
            "Full table scan",
            "Uses index",
            "Loop-based join",
            "Hash-based join"
        ]
    },
    {
        "q": "Rearrange the query optimization priority:",
        "type": "rearrange",
        "words": [
            "Reduce data early",
            "Use indexes",
            "Avoid sorts",
            "Minimize joins",
            "Cache results"
        ]
    },
    {
        "q": "What is table partitioning?",
        "type": "mcq",
        "o": [
            "Splitting a table into smaller physical parts",
            "Copying a table",
            "Creating a view",
            "Indexing columns"
        ]
    },
    {
        "q": "The _____ partitioning divides data by value ranges.",
        "type": "fill_blank",
        "answers": [
            "RANGE"
        ],
        "other_options": [
            "LIST",
            "HASH",
            "KEY"
        ]
    },
    {
        "q": "Partitioning can improve query performance by eliminating partitions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this partition query?",
        "type": "mcq",
        "c": "SELECT * FROM orders_2024 WHERE order_date = '2024-06-15';",
        "o": [
            "Scans only the relevant partition",
            "Scans all partitions",
            "Error - partition not found",
            "Returns no data"
        ]
    },
    {
        "q": "Match the partition type with its use case:",
        "type": "match",
        "left": [
            "RANGE",
            "LIST",
            "HASH",
            "COMPOSITE"
        ],
        "right": [
            "Date ranges",
            "Discrete values",
            "Even distribution",
            "Multiple methods"
        ]
    },
    {
        "q": "Rearrange the partition management steps:",
        "type": "rearrange",
        "words": [
            "Plan strategy",
            "Create partitions",
            "Add data",
            "Maintain partitions",
            "Archive old data"
        ]
    },
    {
        "q": "What is a lateral join?",
        "type": "mcq",
        "o": [
            "A join where the right side can reference the left side",
            "A join with multiple tables",
            "A cross join variant",
            "A self-join"
        ]
    },
    {
        "q": "The _____ keyword enables lateral subqueries.",
        "type": "fill_blank",
        "answers": [
            "LATERAL"
        ],
        "other_options": [
            "CROSS",
            "OUTER",
            "INNER"
        ]
    },
    {
        "q": "LATERAL joins are evaluated for each row of the preceding table.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this LATERAL query?",
        "type": "mcq",
        "c": "SELECT d.name, e.top_salary\nFROM departments d,\nLATERAL (SELECT MAX(salary) AS top_salary FROM employees WHERE dept_id = d.id) e;",
        "o": [
            "Department name with its highest salary",
            "All department-employee combinations",
            "Error - invalid syntax",
            "NULL values"
        ]
    },
    {
        "q": "Match the advanced join with its feature:",
        "type": "match",
        "left": [
            "LATERAL",
            "CROSS APPLY",
            "OUTER APPLY",
            "TABLE function"
        ],
        "right": [
            "Standard SQL lateral",
            "SQL Server lateral",
            "SQL Server outer lateral",
            "Returns rows from function"
        ]
    },
    {
        "q": "Rearrange the join optimization techniques:",
        "type": "rearrange",
        "words": [
            "Filter early",
            "Use proper indexes",
            "Reduce join columns",
            "Consider join order",
            "Use EXPLAIN"
        ]
    },
    {
        "q": "What is a recursive query?",
        "type": "mcq",
        "o": [
            "A query that references itself",
            "A query that runs repeatedly",
            "A query with subqueries",
            "A query on multiple tables"
        ]
    },
    {
        "q": "The _____ CTE requires UNION ALL between anchor and recursive parts.",
        "type": "fill_blank",
        "answers": [
            "RECURSIVE"
        ],
        "other_options": [
            "ITERATIVE",
            "LOOP",
            "REPEAT"
        ]
    },
    {
        "q": "Recursive CTEs can traverse hierarchical data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this hierarchy query?",
        "type": "mcq",
        "c": "WITH RECURSIVE org AS (\n  SELECT id, name, manager_id, 1 as level FROM emp WHERE manager_id IS NULL\n  UNION ALL\n  SELECT e.id, e.name, e.manager_id, o.level + 1\n  FROM emp e JOIN org o ON e.manager_id = o.id\n)\nSELECT * FROM org;",
        "o": [
            "Employee hierarchy with levels",
            "Only top-level managers",
            "Error - infinite loop",
            "Empty result"
        ]
    },
    {
        "q": "Match the hierarchical query term with its meaning:",
        "type": "match",
        "left": [
            "Anchor member",
            "Recursive member",
            "Termination condition",
            "CONNECT BY"
        ],
        "right": [
            "Base case",
            "Iteration step",
            "Stops recursion",
            "Oracle hierarchy syntax"
        ]
    },
    {
        "q": "Rearrange the recursive CTE execution:",
        "type": "rearrange",
        "words": [
            "Execute anchor",
            "Add to result",
            "Execute recursive",
            "Check termination",
            "Repeat or stop"
        ]
    },
    {
        "q": "What is PIVOT in SQL?",
        "type": "mcq",
        "o": [
            "Transforms rows into columns",
            "Transforms columns into rows",
            "Joins tables",
            "Filters data"
        ]
    },
    {
        "q": "The _____ operation transforms columns back into rows.",
        "type": "fill_blank",
        "answers": [
            "UNPIVOT"
        ],
        "other_options": [
            "DEPIVOT",
            "ROTATE",
            "TRANSPOSE"
        ]
    },
    {
        "q": "PIVOT requires an aggregate function.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this PIVOT query?",
        "type": "mcq",
        "c": "SELECT * FROM sales\nPIVOT (SUM(amount) FOR quarter IN ('Q1', 'Q2', 'Q3', 'Q4'));",
        "o": [
            "Quarterly totals as separate columns",
            "Quarterly totals as rows",
            "Error - invalid syntax",
            "NULL values"
        ]
    },
    {
        "q": "Match the transformation with its result:",
        "type": "match",
        "left": [
            "PIVOT",
            "UNPIVOT",
            "CROSSTAB",
            "Dynamic PIVOT"
        ],
        "right": [
            "Rows to columns",
            "Columns to rows",
            "PostgreSQL pivot",
            "Variable columns"
        ]
    },
    {
        "q": "Rearrange the data transformation complexity:",
        "type": "rearrange",
        "words": [
            "Simple SELECT",
            "GROUP BY",
            "PIVOT",
            "Dynamic SQL",
            "Complex ETL"
        ]
    },
    {
        "q": "What is a materialized view?",
        "type": "mcq",
        "o": [
            "A view that stores its result data physically",
            "A temporary view",
            "A view with parameters",
            "A virtual table"
        ]
    },
    {
        "q": "The _____ keyword refreshes a materialized view.",
        "type": "fill_blank",
        "answers": [
            "REFRESH"
        ],
        "other_options": [
            "UPDATE",
            "REBUILD",
            "RECREATE"
        ]
    },
    {
        "q": "Materialized views trade storage space for query speed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this materialized view?",
        "type": "mcq",
        "c": "CREATE MATERIALIZED VIEW sales_summary AS\nSELECT product_id, SUM(quantity) FROM sales GROUP BY product_id;\nSELECT * FROM sales_summary;",
        "o": [
            "Pre-computed product totals from stored data",
            "Computes totals on each query",
            "Error - cannot create",
            "Empty result"
        ]
    },
    {
        "q": "Match the view refresh type with its behavior:",
        "type": "match",
        "left": [
            "COMPLETE",
            "FAST",
            "FORCE",
            "ON COMMIT"
        ],
        "right": [
            "Full rebuild",
            "Incremental update",
            "Try fast then complete",
            "Auto-refresh"
        ]
    },
    {
        "q": "Rearrange the materialized view lifecycle:",
        "type": "rearrange",
        "words": [
            "Create view",
            "Initial load",
            "Query cached data",
            "Refresh view",
            "Drop when obsolete"
        ]
    },
    {
        "q": "What is a database sequence?",
        "type": "mcq",
        "o": [
            "An object that generates sequential numbers",
            "A sorted table",
            "An ordered index",
            "A transaction log"
        ]
    },
    {
        "q": "The _____ function gets the next value from a sequence.",
        "type": "fill_blank",
        "answers": [
            "NEXTVAL"
        ],
        "other_options": [
            "NEXT",
            "INCREMENT",
            "GETVAL"
        ]
    },
    {
        "q": "Sequences guarantee unique values even with concurrent access.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this sequence usage?",
        "type": "mcq",
        "c": "CREATE SEQUENCE order_seq START 1000;\nINSERT INTO orders (id, item) VALUES (NEXTVAL('order_seq'), 'Widget');\nINSERT INTO orders (id, item) VALUES (NEXTVAL('order_seq'), 'Gadget');",
        "o": [
            "Two orders with IDs 1000 and 1001",
            "Two orders with same ID",
            "Error - sequence exhausted",
            "Orders with random IDs"
        ]
    },
    {
        "q": "Match the sequence option with its effect:",
        "type": "match",
        "left": [
            "START WITH",
            "INCREMENT BY",
            "MAXVALUE",
            "CYCLE"
        ],
        "right": [
            "Initial value",
            "Step size",
            "Upper limit",
            "Restart when max reached"
        ]
    },
    {
        "q": "Rearrange the auto-increment methods by portability:",
        "type": "rearrange",
        "words": [
            "SEQUENCE",
            "IDENTITY column",
            "AUTO_INCREMENT",
            "UUID",
            "Application-generated"
        ]
    },
    {
        "q": "What is query caching?",
        "type": "mcq",
        "o": [
            "Storing query results for reuse",
            "Caching execution plans",
            "Storing table data in memory",
            "Buffering network requests"
        ]
    },
    {
        "q": "The _____ cache stores parsed and compiled query plans.",
        "type": "fill_blank",
        "answers": [
            "plan"
        ],
        "other_options": [
            "query",
            "data",
            "buffer"
        ]
    },
    {
        "q": "Query cache is invalidated when underlying data changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this cached query behavior?",
        "type": "mcq",
        "c": "-- Query: SELECT * FROM products WHERE id = 1;\n-- First execution: 100ms\n-- Second execution with cache: ?",
        "o": [
            "Much faster (cache hit)",
            "Same time (no cache)",
            "Slower (cache overhead)",
            "Error"
        ]
    },
    {
        "q": "Match the cache type with its content:",
        "type": "match",
        "left": [
            "Query cache",
            "Plan cache",
            "Buffer pool",
            "Table cache"
        ],
        "right": [
            "Result sets",
            "Execution plans",
            "Data pages",
            "Table metadata"
        ]
    },
    {
        "q": "Rearrange the caching effectiveness factors:",
        "type": "rearrange",
        "words": [
            "Query frequency",
            "Data volatility",
            "Cache size",
            "Query complexity",
            "Memory availability"
        ]
    },
    {
        "q": "What is connection pooling?",
        "type": "mcq",
        "o": [
            "Reusing database connections instead of creating new ones",
            "Connecting multiple databases",
            "Pooling query results",
            "Distributing connections across servers"
        ]
    },
    {
        "q": "The _____ controls maximum concurrent connections in a pool.",
        "type": "fill_blank",
        "answers": [
            "pool size"
        ],
        "other_options": [
            "connection limit",
            "max threads",
            "queue size"
        ]
    },
    {
        "q": "Connection pooling reduces the overhead of connection creation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this pool behavior?",
        "type": "mcq",
        "c": "-- Pool size: 10\n-- Current connections: 10\n-- New request arrives\n-- Pool behavior: ?",
        "o": [
            "Request waits until connection is available",
            "New connection created immediately",
            "Request rejected",
            "Error occurs"
        ]
    },
    {
        "q": "Match the pool parameter with its purpose:",
        "type": "match",
        "left": [
            "Min size",
            "Max size",
            "Idle timeout",
            "Connection lifetime"
        ],
        "right": [
            "Minimum connections",
            "Maximum connections",
            "Close unused connections",
            "Force reconnection"
        ]
    },
    {
        "q": "Rearrange the connection lifecycle:",
        "type": "rearrange",
        "words": [
            "Request connection",
            "Get from pool",
            "Use connection",
            "Return to pool",
            "Eventual close"
        ]
    },
    {
        "q": "What is a generated column?",
        "type": "mcq",
        "o": [
            "A column whose value is computed from other columns",
            "An auto-increment column",
            "A column with default value",
            "A virtual table column"
        ]
    },
    {
        "q": "The _____ generated column stores computed values.",
        "type": "fill_blank",
        "answers": [
            "STORED"
        ],
        "other_options": [
            "VIRTUAL",
            "COMPUTED",
            "DERIVED"
        ]
    },
    {
        "q": "Virtual generated columns do not consume storage space.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this generated column?",
        "type": "mcq",
        "c": "CREATE TABLE products (\n  price DECIMAL(10,2),\n  tax_rate DECIMAL(5,2),\n  total AS (price * (1 + tax_rate)) STORED\n);\nINSERT INTO products (price, tax_rate) VALUES (100, 0.10);\nSELECT total FROM products;",
        "o": [
            "110.00",
            "100.00",
            "10.00",
            "NULL"
        ]
    },
    {
        "q": "Match the column type with its characteristic:",
        "type": "match",
        "left": [
            "Regular column",
            "Generated stored",
            "Generated virtual",
            "Computed column"
        ],
        "right": [
            "User-provided value",
            "Stored calculation",
            "On-demand calculation",
            "SQL Server term"
        ]
    },
    {
        "q": "Rearrange the column constraint checking order:",
        "type": "rearrange",
        "words": [
            "NOT NULL",
            "CHECK constraint",
            "UNIQUE",
            "FOREIGN KEY",
            "Trigger validation"
        ]
    },
    {
        "q": "What is a JSON column in SQL?",
        "type": "mcq",
        "o": [
            "A column that stores JSON data with special query capabilities",
            "A regular text column",
            "A column for JavaScript code",
            "A column for arrays only"
        ]
    },
    {
        "q": "The _____ operator extracts a value from JSON in PostgreSQL.",
        "type": "fill_blank",
        "answers": [
            "->"
        ],
        "other_options": [
            ".",
            "[]",
            "::"
        ]
    },
    {
        "q": "JSON columns can be indexed for faster querying.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this JSON query?",
        "type": "mcq",
        "c": "SELECT data->>'name' FROM users WHERE data->>'age' > '30';",
        "o": [
            "Names of users over 30 from JSON data column",
            "All user names",
            "Error - invalid JSON syntax",
            "Empty result"
        ]
    },
    {
        "q": "Match the JSON function with its purpose:",
        "type": "match",
        "left": [
            "JSON_EXTRACT",
            "JSON_OBJECT",
            "JSON_ARRAY",
            "JSON_SET"
        ],
        "right": [
            "Get value from path",
            "Create JSON object",
            "Create JSON array",
            "Modify JSON value"
        ]
    },
    {
        "q": "Rearrange the JSON query complexity:",
        "type": "rearrange",
        "words": [
            "Extract scalar",
            "Navigate nested",
            "Query arrays",
            "Update JSON",
            "Index JSON paths"
        ]
    },
    {
        "q": "What is MERGE statement?",
        "type": "mcq",
        "o": [
            "Combines INSERT, UPDATE, and DELETE in one statement",
            "Joins two tables",
            "Merges databases",
            "Combines query results"
        ]
    },
    {
        "q": "The _____ clause specifies the join condition in MERGE.",
        "type": "fill_blank",
        "answers": [
            "ON"
        ],
        "other_options": [
            "WHERE",
            "WHEN",
            "USING"
        ]
    },
    {
        "q": "MERGE is also known as UPSERT.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this MERGE statement?",
        "type": "mcq",
        "c": "MERGE INTO target t\nUSING source s ON t.id = s.id\nWHEN MATCHED THEN UPDATE SET t.value = s.value\nWHEN NOT MATCHED THEN INSERT (id, value) VALUES (s.id, s.value);",
        "o": [
            "Updates existing rows, inserts new rows",
            "Only updates existing rows",
            "Only inserts new rows",
            "Error - invalid syntax"
        ]
    },
    {
        "q": "Match the MERGE clause with its action:",
        "type": "match",
        "left": [
            "WHEN MATCHED",
            "WHEN NOT MATCHED",
            "WHEN NOT MATCHED BY SOURCE",
            "USING"
        ],
        "right": [
            "Update or delete",
            "Insert new",
            "Delete orphans",
            "Source table"
        ]
    },
    {
        "q": "Rearrange the MERGE statement parts:",
        "type": "rearrange",
        "words": [
            "MERGE INTO",
            "USING source",
            "ON condition",
            "WHEN clauses",
            "Actions"
        ]
    },
    {
        "q": "What is a database schema?",
        "type": "mcq",
        "o": [
            "A namespace for organizing database objects",
            "A table structure",
            "A database backup",
            "A user account"
        ]
    },
    {
        "q": "The _____ schema contains default objects for a user.",
        "type": "fill_blank",
        "answers": [
            "public"
        ],
        "other_options": [
            "default",
            "dbo",
            "system"
        ]
    },
    {
        "q": "Objects in different schemas can have the same name.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this schema-qualified query?",
        "type": "mcq",
        "c": "SELECT * FROM sales.orders;\nSELECT * FROM hr.employees;",
        "o": [
            "Queries tables in different schemas",
            "Queries tables in same schema",
            "Error - schema not found",
            "Joins the tables"
        ]
    },
    {
        "q": "Match the schema concept with its database:",
        "type": "match",
        "left": [
            "schema.table",
            "database.schema.table",
            "owner.table",
            "tablespace"
        ],
        "right": [
            "Standard qualification",
            "SQL Server full path",
            "Oracle style",
            "Physical storage"
        ]
    },
    {
        "q": "Rearrange the database object hierarchy:",
        "type": "rearrange",
        "words": [
            "Server/Instance",
            "Database",
            "Schema",
            "Table",
            "Column"
        ]
    },
    {
        "q": "What is a database user vs a role?",
        "type": "mcq",
        "o": [
            "User is an account, role is a collection of privileges",
            "User and role are identical",
            "Role is an account, user is a privilege",
            "Neither is used in databases"
        ]
    },
    {
        "q": "The _____ statement gives permissions to a user.",
        "type": "fill_blank",
        "answers": [
            "GRANT"
        ],
        "other_options": [
            "ALLOW",
            "PERMIT",
            "ENABLE"
        ]
    },
    {
        "q": "Roles can be granted to other roles.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this permission grant?",
        "type": "mcq",
        "c": "GRANT SELECT, INSERT ON employees TO analyst_role;\nGRANT analyst_role TO john;",
        "o": [
            "John can SELECT and INSERT on employees",
            "John can only SELECT",
            "John has no permissions",
            "Error - invalid grant"
        ]
    },
    {
        "q": "Match the permission with its scope:",
        "type": "match",
        "left": [
            "SELECT",
            "INSERT",
            "DELETE",
            "EXECUTE"
        ],
        "right": [
            "Read data",
            "Add data",
            "Remove data",
            "Run procedures"
        ]
    },
    {
        "q": "Rearrange the permission inheritance chain:",
        "type": "rearrange",
        "words": [
            "Database permissions",
            "Schema permissions",
            "Table permissions",
            "Column permissions"
        ]
    },
    {
        "q": "What is row-level security (RLS)?",
        "type": "mcq",
        "o": [
            "Restricting row access based on user context",
            "Encrypting individual rows",
            "Locking rows during updates",
            "Validating row data"
        ]
    },
    {
        "q": "The _____ creates a security policy in PostgreSQL RLS.",
        "type": "fill_blank",
        "answers": [
            "CREATE POLICY"
        ],
        "other_options": [
            "CREATE RULE",
            "CREATE FILTER",
            "CREATE ACCESS"
        ]
    },
    {
        "q": "Row-level security can be bypassed by superusers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this RLS policy?",
        "type": "mcq",
        "c": "CREATE POLICY tenant_policy ON orders\nUSING (tenant_id = current_user_tenant());\nSELECT * FROM orders;",
        "o": [
            "Only orders for current user's tenant",
            "All orders",
            "No orders",
            "Error - policy not applied"
        ]
    },
    {
        "q": "Match the security feature with its level:",
        "type": "match",
        "left": [
            "Row-level security",
            "Column-level security",
            "Schema permissions",
            "Database roles"
        ],
        "right": [
            "Row filtering",
            "Column masking",
            "Object access",
            "User grouping"
        ]
    },
    {
        "q": "Rearrange the security implementation order:",
        "type": "rearrange",
        "words": [
            "Authentication",
            "Authorization",
            "Row-level security",
            "Column masking",
            "Audit logging"
        ]
    },
    {
        "q": "What is a temporal table?",
        "type": "mcq",
        "o": [
            "A table that maintains history of data changes",
            "A temporary table",
            "A table with date columns",
            "A scheduled table"
        ]
    },
    {
        "q": "The _____ period tracks when a row was valid in temporal tables.",
        "type": "fill_blank",
        "answers": [
            "SYSTEM_TIME"
        ],
        "other_options": [
            "VALID_TIME",
            "TRANSACTION_TIME",
            "APPLICATION_TIME"
        ]
    },
    {
        "q": "Temporal tables automatically maintain a history table.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this temporal query?",
        "type": "mcq",
        "c": "SELECT * FROM employees FOR SYSTEM_TIME AS OF '2024-01-01';\n-- Current date is 2024-06-15",
        "o": [
            "Employee data as it was on January 1st, 2024",
            "Current employee data",
            "All historical versions",
            "Error - invalid syntax"
        ]
    },
    {
        "q": "Match the temporal query with its result:",
        "type": "match",
        "left": [
            "AS OF",
            "FROM...TO",
            "BETWEEN...AND",
            "CONTAINED IN"
        ],
        "right": [
            "Point in time",
            "Period range exclusive",
            "Period range inclusive",
            "Fully within period"
        ]
    },
    {
        "q": "Rearrange the temporal table components:",
        "type": "rearrange",
        "words": [
            "Main table",
            "History table",
            "Period columns",
            "System versioning",
            "Retention policy"
        ]
    },
    {
        "q": "What is database sharding?",
        "type": "mcq",
        "o": [
            "Distributing data across multiple databases",
            "Backing up the database",
            "Encrypting database files",
            "Compressing tables"
        ]
    },
    {
        "q": "The _____ determines which shard holds a specific record.",
        "type": "fill_blank",
        "answers": [
            "shard key"
        ],
        "other_options": [
            "primary key",
            "foreign key",
            "partition key"
        ]
    },
    {
        "q": "Cross-shard queries are more expensive than single-shard queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this sharding scenario?",
        "type": "mcq",
        "c": "-- Shard key: user_id\n-- User 12345 queries their orders\n-- Sharding strategy: hash(user_id) % 4",
        "o": [
            "Query goes to a single shard",
            "Query goes to all shards",
            "Query fails",
            "Query uses random shard"
        ]
    },
    {
        "q": "Match the sharding strategy with its use case:",
        "type": "match",
        "left": [
            "Hash sharding",
            "Range sharding",
            "Directory sharding",
            "Geographic sharding"
        ],
        "right": [
            "Even distribution",
            "Time-based queries",
            "Flexible mapping",
            "Location-based access"
        ]
    },
    {
        "q": "Rearrange the horizontal scaling steps:",
        "type": "rearrange",
        "words": [
            "Identify bottleneck",
            "Choose sharding key",
            "Migrate data",
            "Update application",
            "Monitor distribution"
        ]
    },
    {
        "q": "What is database replication?",
        "type": "mcq",
        "o": [
            "Copying data to multiple database servers",
            "Duplicating queries",
            "Backing up to tape",
            "Creating views"
        ]
    },
    {
        "q": "The _____ replication mode waits for confirmation from replicas.",
        "type": "fill_blank",
        "answers": [
            "synchronous"
        ],
        "other_options": [
            "asynchronous",
            "delayed",
            "immediate"
        ]
    },
    {
        "q": "Asynchronous replication may have replication lag.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this replication setup?",
        "type": "mcq",
        "c": "-- Primary: INSERT INTO orders VALUES (1, 'new');\n-- Synchronous replica with 100ms network latency",
        "o": [
            "Commit waits for replica acknowledgment",
            "Commit returns immediately",
            "Insert fails",
            "Data is only on primary"
        ]
    },
    {
        "q": "Match the replication type with its characteristic:",
        "type": "match",
        "left": [
            "Master-slave",
            "Master-master",
            "Cascading",
            "Logical"
        ],
        "right": [
            "One writer",
            "Multiple writers",
            "Chained replicas",
            "Row-level changes"
        ]
    },
    {
        "q": "Rearrange the failover process:",
        "type": "rearrange",
        "words": [
            "Detect failure",
            "Elect new primary",
            "Redirect connections",
            "Resync old primary",
            "Resume operations"
        ]
    },
    {
        "q": "What is a query hint?",
        "type": "mcq",
        "o": [
            "A directive to the query optimizer",
            "A comment in SQL",
            "An error message",
            "A query suggestion"
        ]
    },
    {
        "q": "The _____ hint forces use of a specific index.",
        "type": "fill_blank",
        "answers": [
            "FORCE INDEX"
        ],
        "other_options": [
            "USE INDEX",
            "HINT INDEX",
            "REQUIRE INDEX"
        ]
    },
    {
        "q": "Query hints can override the optimizer's decisions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this hint usage?",
        "type": "mcq",
        "c": "SELECT /*+ INDEX(employees idx_salary) */ *\nFROM employees WHERE salary > 50000;",
        "o": [
            "Uses idx_salary index regardless of optimizer choice",
            "Uses default query plan",
            "Error - invalid hint",
            "Ignores the hint"
        ]
    },
    {
        "q": "Match the hint type with its effect:",
        "type": "match",
        "left": [
            "INDEX hint",
            "PARALLEL hint",
            "NO_MERGE hint",
            "LEADING hint"
        ],
        "right": [
            "Force index use",
            "Use parallel execution",
            "Prevent view merge",
            "Specify join order"
        ]
    },
    {
        "q": "Rearrange the query tuning priority:",
        "type": "rearrange",
        "words": [
            "Schema design",
            "Indexing",
            "Query rewrite",
            "Hints",
            "Parameter tuning"
        ]
    },
    {
        "q": "What is cost-based optimization?",
        "type": "mcq",
        "o": [
            "Choosing execution plan based on estimated resource usage",
            "Optimizing database costs",
            "Reducing query complexity",
            "Minimizing table size"
        ]
    },
    {
        "q": "The optimizer uses _____ to estimate query costs.",
        "type": "fill_blank",
        "answers": [
            "statistics"
        ],
        "other_options": [
            "indexes",
            "constraints",
            "triggers"
        ]
    },
    {
        "q": "Stale statistics can lead to suboptimal query plans.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this statistics update?",
        "type": "mcq",
        "c": "ANALYZE TABLE orders;\n-- After bulk insert of 1 million rows",
        "o": [
            "Statistics updated for better query planning",
            "Data is analyzed for errors",
            "Table is optimized",
            "Indexes are rebuilt"
        ]
    },
    {
        "q": "Match the optimization phase with its action:",
        "type": "match",
        "left": [
            "Parsing",
            "Binding",
            "Optimization",
            "Execution"
        ],
        "right": [
            "Check syntax",
            "Resolve names",
            "Choose plan",
            "Run query"
        ]
    },
    {
        "q": "Rearrange the query execution phases:",
        "type": "rearrange",
        "words": [
            "Parse SQL",
            "Create plan",
            "Execute plan",
            "Fetch results",
            "Return to client"
        ]
    },
    {
        "q": "What is query plan caching?",
        "type": "mcq",
        "o": [
            "Storing compiled query plans for reuse",
            "Caching query results",
            "Storing table data",
            "Buffering network data"
        ]
    },
    {
        "q": "The _____ allows plan reuse with different parameter values.",
        "type": "fill_blank",
        "answers": [
            "parameterized query"
        ],
        "other_options": [
            "dynamic query",
            "cached query",
            "prepared statement"
        ]
    },
    {
        "q": "Plan cache entries can be evicted under memory pressure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this prepared statement?",
        "type": "mcq",
        "c": "PREPARE user_query AS SELECT * FROM users WHERE id = $1;\nEXECUTE user_query(123);\nEXECUTE user_query(456);",
        "o": [
            "Same plan reused with different parameter values",
            "New plan created each time",
            "Error - invalid syntax",
            "First query only executes"
        ]
    },
    {
        "q": "Match the plan reuse scenario with its behavior:",
        "type": "match",
        "left": [
            "Parameterized query",
            "Ad-hoc query",
            "Forced parameterization",
            "Plan guides"
        ],
        "right": [
            "Automatic reuse",
            "Usually no reuse",
            "Database forces parameters",
            "Manual plan control"
        ]
    },
    {
        "q": "Rearrange the performance troubleshooting steps:",
        "type": "rearrange",
        "words": [
            "Identify slow query",
            "Capture execution plan",
            "Analyze bottleneck",
            "Apply fix",
            "Verify improvement"
        ]
    },
    {
        "q": "What is an index-only scan?",
        "type": "mcq",
        "o": [
            "Query satisfied entirely from the index without table access",
            "Scanning only one index",
            "Creating an index during scan",
            "Scanning index in one direction"
        ]
    },
    {
        "q": "The _____ index includes non-key columns to enable index-only scans.",
        "type": "fill_blank",
        "answers": [
            "covering"
        ],
        "other_options": [
            "composite",
            "unique",
            "partial"
        ]
    },
    {
        "q": "Index-only scans are faster because they avoid table lookups.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this index scenario?",
        "type": "mcq",
        "c": "-- Index on (department_id, salary)\nSELECT department_id, salary FROM employees\nWHERE department_id = 10;",
        "o": [
            "Index-only scan possible",
            "Table scan required",
            "Error - cannot use index",
            "Index scan plus table lookup"
        ]
    },
    {
        "q": "Match the scan type with its data access:",
        "type": "match",
        "left": [
            "Seq Scan",
            "Index Scan",
            "Index Only Scan",
            "Bitmap Scan"
        ],
        "right": [
            "Full table read",
            "Index then table",
            "Index only",
            "Batch row retrieval"
        ]
    },
    {
        "q": "Rearrange index types by space efficiency:",
        "type": "rearrange",
        "words": [
            "Partial index",
            "Regular index",
            "Covering index",
            "Full-text index"
        ]
    },
    {
        "q": "What is a bloom filter index?",
        "type": "mcq",
        "o": [
            "Probabilistic index for fast negative lookups",
            "Index for text search",
            "Index for numeric ranges",
            "Index for spatial data"
        ]
    },
    {
        "q": "Bloom filters can have _____ positives but never false negatives.",
        "type": "fill_blank",
        "answers": [
            "false"
        ],
        "other_options": [
            "true",
            "uncertain",
            "duplicate"
        ]
    },
    {
        "q": "Bloom filters use significantly less space than traditional indexes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this bloom filter check?",
        "type": "mcq",
        "c": "-- Bloom filter on column 'email'\n-- Query: WHERE email = 'test@example.com'\n-- Bloom filter returns: possibly exists",
        "o": [
            "Must check actual data to confirm",
            "Definitely exists",
            "Definitely not exists",
            "Query fails"
        ]
    },
    {
        "q": "Match the index structure with its use case:",
        "type": "match",
        "left": [
            "B-tree",
            "Hash index",
            "GiST",
            "Bloom filter"
        ],
        "right": [
            "Range queries",
            "Equality only",
            "Geometric data",
            "Membership test"
        ]
    },
    {
        "q": "Rearrange the index maintenance operations:",
        "type": "rearrange",
        "words": [
            "Monitor fragmentation",
            "Identify unused indexes",
            "Rebuild fragmented",
            "Drop unused",
            "Add new indexes"
        ]
    },
    {
        "q": "What is database checkpoint?",
        "type": "mcq",
        "o": [
            "Writing dirty pages to disk for consistency",
            "Backing up the database",
            "Marking transaction completion",
            "Validating data integrity"
        ]
    },
    {
        "q": "The _____ log records all database changes for recovery.",
        "type": "fill_blank",
        "answers": [
            "WAL"
        ],
        "other_options": [
            "audit",
            "error",
            "query"
        ]
    },
    {
        "q": "Checkpoints ensure data can be recovered after a crash.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this recovery scenario?",
        "type": "mcq",
        "c": "-- Database crashes after:\n-- 1. Transaction commits (logged)\n-- 2. Before checkpoint completes",
        "o": [
            "Transaction recovered from WAL",
            "Transaction lost",
            "Database corrupted",
            "Manual recovery required"
        ]
    },
    {
        "q": "Match the recovery component with its function:",
        "type": "match",
        "left": [
            "WAL",
            "Checkpoint",
            "Redo log",
            "Undo log"
        ],
        "right": [
            "Change journal",
            "Periodic sync",
            "Replay changes",
            "Rollback changes"
        ]
    },
    {
        "q": "Rearrange the crash recovery process:",
        "type": "rearrange",
        "words": [
            "Find last checkpoint",
            "Redo committed",
            "Undo uncommitted",
            "Open database",
            "Resume operations"
        ]
    },
    {
        "q": "What is multi-version concurrency control (MVCC)?",
        "type": "mcq",
        "o": [
            "Maintaining multiple versions of rows for concurrent access",
            "Version control for database schemas",
            "Multiple database versions",
            "Concurrent update merging"
        ]
    },
    {
        "q": "MVCC allows readers to not block _____.",
        "type": "fill_blank",
        "answers": [
            "writers"
        ],
        "other_options": [
            "readers",
            "admins",
            "transactions"
        ]
    },
    {
        "q": "MVCC creates row versions instead of using locks for reads.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this MVCC scenario?",
        "type": "mcq",
        "c": "-- Transaction A: SELECT salary FROM emp WHERE id=1; (returns 50000)\n-- Transaction B: UPDATE emp SET salary=60000 WHERE id=1; COMMIT;\n-- Transaction A (same txn): SELECT salary FROM emp WHERE id=1;",
        "o": [
            "Still returns 50000 (reads consistent snapshot)",
            "Returns 60000",
            "Blocks until A commits",
            "Error - concurrent modification"
        ]
    },
    {
        "q": "Match the MVCC concept with its meaning:",
        "type": "match",
        "left": [
            "Snapshot",
            "Row version",
            "Vacuum",
            "Transaction ID"
        ],
        "right": [
            "Consistent view",
            "Multiple row states",
            "Clean old versions",
            "Version visibility"
        ]
    },
    {
        "q": "Rearrange the MVCC overhead concerns:",
        "type": "rearrange",
        "words": [
            "Storage for versions",
            "Vacuum overhead",
            "Version checking",
            "ID wraparound"
        ]
    },
    {
        "q": "What is pessimistic locking?",
        "type": "mcq",
        "o": [
            "Acquiring locks before accessing data",
            "Checking for conflicts after",
            "No locking at all",
            "Automatic conflict resolution"
        ]
    },
    {
        "q": "The _____ keyword acquires a pessimistic lock in SQL.",
        "type": "fill_blank",
        "answers": [
            "FOR UPDATE"
        ],
        "other_options": [
            "WITH LOCK",
            "LOCK",
            "EXCLUSIVE"
        ]
    },
    {
        "q": "Pessimistic locking can lead to reduced concurrency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this locking comparison?",
        "type": "mcq",
        "c": "-- Pessimistic: SELECT * FROM inventory WHERE id=1 FOR UPDATE;\n-- Two users try to update same row simultaneously",
        "o": [
            "Second user waits for first to complete",
            "Both updates succeed immediately",
            "Second user gets stale data",
            "Both updates fail"
        ]
    },
    {
        "q": "Match the locking strategy with its approach:",
        "type": "match",
        "left": [
            "Pessimistic",
            "Optimistic",
            "No locking",
            "Hybrid"
        ],
        "right": [
            "Lock before access",
            "Check at commit",
            "Eventual consistency",
            "Lock critical sections"
        ]
    },
    {
        "q": "Rearrange the concurrency strategies by contention handling:",
        "type": "rearrange",
        "words": [
            "Optimistic (low contention)",
            "MVCC",
            "Row locking",
            "Table locking",
            "Database locking"
        ]
    },
    {
        "q": "What is eventual consistency?",
        "type": "mcq",
        "o": [
            "Data will become consistent after some time",
            "Data is always immediately consistent",
            "Data is never consistent",
            "Consistency is optional"
        ]
    },
    {
        "q": "The _____ theorem states you cannot have CA during partition.",
        "type": "fill_blank",
        "answers": [
            "CAP"
        ],
        "other_options": [
            "BASE",
            "ACID",
            "SOLID"
        ]
    },
    {
        "q": "Strong consistency has higher latency than eventual consistency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this consistency scenario?",
        "type": "mcq",
        "c": "-- Write to primary (US)\n-- Read from replica (Europe)\n-- Replication lag: 100ms",
        "o": [
            "May see stale data until replication completes",
            "Always sees latest data",
            "Read fails",
            "Data is corrupted"
        ]
    },
    {
        "q": "Match the consistency level with its guarantee:",
        "type": "match",
        "left": [
            "Strong",
            "Eventual",
            "Causal",
            "Read-your-writes"
        ],
        "right": [
            "Immediate",
            "Eventually",
            "Ordered causality",
            "See own writes"
        ]
    },
    {
        "q": "Rearrange the consistency models by strictness:",
        "type": "rearrange",
        "words": [
            "Eventual",
            "Causal",
            "Sequential",
            "Linearizable",
            "Strict serializable"
        ]
    },
    {
        "q": "What is a distributed transaction?",
        "type": "mcq",
        "o": [
            "A transaction spanning multiple databases or services",
            "A transaction with multiple statements",
            "A partitioned transaction",
            "A replicated transaction"
        ]
    },
    {
        "q": "The _____ protocol coordinates distributed transactions.",
        "type": "fill_blank",
        "answers": [
            "two-phase commit"
        ],
        "other_options": [
            "three-phase commit",
            "consensus",
            "replication"
        ]
    },
    {
        "q": "Two-phase commit can block if the coordinator fails.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this 2PC scenario?",
        "type": "mcq",
        "c": "-- Coordinator sends PREPARE\n-- All participants vote YES\n-- Coordinator fails before sending COMMIT\n-- Participants in PREPARED state",
        "o": [
            "Participants block waiting for coordinator recovery",
            "Participants automatically commit",
            "Participants automatically rollback",
            "Transaction continues normally"
        ]
    },
    {
        "q": "Match the distributed transaction term with its role:",
        "type": "match",
        "left": [
            "Coordinator",
            "Participant",
            "Prepare phase",
            "Commit phase"
        ],
        "right": [
            "Manages transaction",
            "Executes locally",
            "Vote to commit",
            "Final decision"
        ]
    },
    {
        "q": "Rearrange the 2PC phases:",
        "type": "rearrange",
        "words": [
            "Begin transaction",
            "Prepare request",
            "Vote response",
            "Commit decision",
            "Acknowledgment"
        ]
    },
    {
        "q": "What is a saga pattern?",
        "type": "mcq",
        "o": [
            "Managing distributed transactions through compensating actions",
            "A storytelling database pattern",
            "Sequential query execution",
            "A type of stored procedure"
        ]
    },
    {
        "q": "The _____ saga executes steps through events.",
        "type": "fill_blank",
        "answers": [
            "choreography"
        ],
        "other_options": [
            "orchestration",
            "coordination",
            "synchronization"
        ]
    },
    {
        "q": "Sagas provide eventual consistency rather than ACID.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this saga failure?",
        "type": "mcq",
        "c": "-- Step 1: Create order (SUCCESS)\n-- Step 2: Reserve inventory (SUCCESS)\n-- Step 3: Process payment (FAILURE)\n-- Saga behavior:",
        "o": [
            "Executes compensating transactions for steps 1 and 2",
            "Retries step 3 indefinitely",
            "Leaves system in inconsistent state",
            "Rolls back entire database"
        ]
    },
    {
        "q": "Match the saga type with its coordination:",
        "type": "match",
        "left": [
            "Choreography",
            "Orchestration",
            "Compensating transaction",
            "Pivot transaction"
        ],
        "right": [
            "Event-driven",
            "Central coordinator",
            "Undo action",
            "Point of no return"
        ]
    },
    {
        "q": "Rearrange the saga compensation order:",
        "type": "rearrange",
        "words": [
            "Detect failure",
            "Stop forward progress",
            "Execute compensations",
            "Handle compensation failures",
            "Report outcome"
        ]
    },
    {
        "q": "What is the buffer pool in a database?",
        "type": "mcq",
        "o": [
            "Memory cache for data pages",
            "Network buffer",
            "Query result cache",
            "Connection pool"
        ]
    },
    {
        "q": "The _____ algorithm decides which pages to evict from buffer pool.",
        "type": "fill_blank",
        "answers": [
            "LRU"
        ],
        "other_options": [
            "FIFO",
            "LIFO",
            "Random"
        ]
    },
    {
        "q": "A larger buffer pool generally improves read performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this buffer pool scenario?",
        "type": "mcq",
        "c": "-- Buffer pool: 1GB\n-- Table size: 2GB\n-- Query: Sequential scan of entire table\n-- Buffer pool behavior:",
        "o": [
            "Pages evicted as new pages are read",
            "Query fails - insufficient memory",
            "Entire table cached",
            "Query runs in memory only"
        ]
    },
    {
        "q": "Match the buffer pool metric with its meaning:",
        "type": "match",
        "left": [
            "Hit ratio",
            "Miss ratio",
            "Dirty pages",
            "Free pages"
        ],
        "right": [
            "Found in cache",
            "Read from disk",
            "Modified not written",
            "Available space"
        ]
    },
    {
        "q": "Rearrange the data access path:",
        "type": "rearrange",
        "words": [
            "Query request",
            "Check buffer pool",
            "Read from disk",
            "Load to buffer",
            "Return data"
        ]
    },
    {
        "q": "What is write-ahead logging (WAL)?",
        "type": "mcq",
        "o": [
            "Logging changes before modifying data pages",
            "Writing data then logging",
            "Synchronous logging only",
            "Logging after commit"
        ]
    },
    {
        "q": "WAL ensures _____ by logging before data modification.",
        "type": "fill_blank",
        "answers": [
            "durability"
        ],
        "other_options": [
            "consistency",
            "atomicity",
            "isolation"
        ]
    },
    {
        "q": "WAL log is typically stored on fast, durable storage.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this WAL scenario?",
        "type": "mcq",
        "c": "-- Transaction: UPDATE account SET balance = 1000\n-- WAL write: SUCCESS\n-- Data page write: IN PROGRESS\n-- System crash",
        "o": [
            "Change recovered from WAL on restart",
            "Change lost",
            "Partial update visible",
            "Database corrupted"
        ]
    },
    {
        "q": "Match the WAL component with its purpose:",
        "type": "match",
        "left": [
            "LSN",
            "Redo record",
            "Undo record",
            "Checkpoint record"
        ],
        "right": [
            "Log sequence number",
            "Replay change",
            "Rollback change",
            "Recovery point"
        ]
    },
    {
        "q": "Rearrange the WAL write sequence:",
        "type": "rearrange",
        "words": [
            "Modify in memory",
            "Write WAL record",
            "Sync WAL to disk",
            "Acknowledge commit",
            "Eventually write data"
        ]
    },
    {
        "q": "What is a B+ tree index?",
        "type": "mcq",
        "o": [
            "Tree structure with all data in leaf nodes",
            "Binary search tree for databases",
            "Balanced tree with data in all nodes",
            "Hash-based tree structure"
        ]
    },
    {
        "q": "B+ tree leaf nodes are linked for _____ scans.",
        "type": "fill_blank",
        "answers": [
            "range"
        ],
        "other_options": [
            "point",
            "full",
            "reverse"
        ]
    },
    {
        "q": "B+ trees maintain balance through node splits and merges.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this B+ tree operation?",
        "type": "mcq",
        "c": "-- B+ tree order: 4\n-- Current leaf: [1, 2, 3]\n-- Insert: 4\n-- Result:",
        "o": [
            "Node splits into two leaves",
            "Value added to same leaf",
            "Insert fails",
            "Tree rebuilds completely"
        ]
    },
    {
        "q": "Match the B+ tree property with its benefit:",
        "type": "match",
        "left": [
            "Balanced height",
            "Leaf node links",
            "High fan-out",
            "Sorted leaves"
        ],
        "right": [
            "Predictable access",
            "Range scans",
            "Shallow tree",
            "Ordered output"
        ]
    },
    {
        "q": "Rearrange the B+ tree lookup steps:",
        "type": "rearrange",
        "words": [
            "Start at root",
            "Binary search in node",
            "Follow pointer",
            "Reach leaf",
            "Find value"
        ]
    },
    {
        "q": "What is a skip list?",
        "type": "mcq",
        "o": [
            "Probabilistic data structure with multiple levels",
            "List that skips null values",
            "Compressed linked list",
            "Sorted array variant"
        ]
    },
    {
        "q": "Skip lists provide _____ average case complexity for search.",
        "type": "fill_blank",
        "answers": [
            "O(log n)"
        ],
        "other_options": [
            "O(n)",
            "O(1)",
            "O(n log n)"
        ]
    },
    {
        "q": "Skip lists are used in some LSM-tree implementations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this skip list search?",
        "type": "mcq",
        "c": "-- Skip list levels: 4\n-- Searching for: 50\n-- Start at top level, jump forward until value > 50\n-- Then descend",
        "o": [
            "Logarithmic hops to find value",
            "Linear scan required",
            "Hash lookup used",
            "Binary search on all elements"
        ]
    },
    {
        "q": "Match the data structure with its use case:",
        "type": "match",
        "left": [
            "B+ tree",
            "Skip list",
            "LSM tree",
            "Hash table"
        ],
        "right": [
            "Disk indexes",
            "In-memory sorted",
            "Write-heavy",
            "Point lookups"
        ]
    },
    {
        "q": "Rearrange the index structures by write performance:",
        "type": "rearrange",
        "words": [
            "LSM tree",
            "B-epsilon tree",
            "B+ tree",
            "Hash index"
        ]
    },
    {
        "q": "What is an LSM tree?",
        "type": "mcq",
        "o": [
            "Log-structured merge tree for write-heavy workloads",
            "Large sorted memory tree",
            "Linear storage manager tree",
            "Linked segment map tree"
        ]
    },
    {
        "q": "LSM trees use _____ to merge sorted runs.",
        "type": "fill_blank",
        "answers": [
            "compaction"
        ],
        "other_options": [
            "merging",
            "sorting",
            "indexing"
        ]
    },
    {
        "q": "LSM trees trade read performance for write performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this LSM write?",
        "type": "mcq",
        "c": "-- Write: INSERT INTO data VALUES (1, 'value')\n-- LSM tree behavior:",
        "o": [
            "Write to memory table, later flush to disk",
            "Direct write to sorted file",
            "Update B+ tree immediately",
            "Write to hash table"
        ]
    },
    {
        "q": "Match the LSM component with its role:",
        "type": "match",
        "left": [
            "Memtable",
            "SSTable",
            "Bloom filter",
            "Compaction"
        ],
        "right": [
            "In-memory writes",
            "On-disk sorted",
            "Skip absent keys",
            "Merge files"
        ]
    },
    {
        "q": "Rearrange the LSM write path:",
        "type": "rearrange",
        "words": [
            "Write to memtable",
            "WAL sync",
            "Memtable full",
            "Flush to SSTable",
            "Trigger compaction"
        ]
    },
    {
        "q": "What is query compilation?",
        "type": "mcq",
        "o": [
            "Converting SQL to executable code",
            "Compiling stored procedures",
            "Creating query strings",
            "Building execution statistics"
        ]
    },
    {
        "q": "JIT _____ can speed up repeated query execution.",
        "type": "fill_blank",
        "answers": [
            "compilation"
        ],
        "other_options": [
            "optimization",
            "parsing",
            "planning"
        ]
    },
    {
        "q": "Query compilation has overhead that may not benefit simple queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this JIT scenario?",
        "type": "mcq",
        "c": "-- Complex aggregate query\n-- First execution: 100ms (includes JIT compilation)\n-- Subsequent executions:",
        "o": [
            "Faster (compiled code reused)",
            "Same time",
            "Slower (cache miss)",
            "Varies randomly"
        ]
    },
    {
        "q": "Match the compilation approach with its characteristic:",
        "type": "match",
        "left": [
            "Interpreted",
            "JIT compiled",
            "Ahead-of-time",
            "Vectorized"
        ],
        "right": [
            "Flexible but slower",
            "Compile at runtime",
            "Pre-compiled",
            "SIMD operations"
        ]
    },
    {
        "q": "Rearrange the query processing evolution:",
        "type": "rearrange",
        "words": [
            "Interpreted",
            "Vectorized",
            "JIT compiled",
            "Hardware-aware"
        ]
    },
    {
        "q": "What is vectorized query execution?",
        "type": "mcq",
        "o": [
            "Processing data in batches using SIMD instructions",
            "Parallel query execution",
            "Vector database queries",
            "GPU-accelerated queries"
        ]
    },
    {
        "q": "Vectorized execution processes _____ at a time.",
        "type": "fill_blank",
        "answers": [
            "batches"
        ],
        "other_options": [
            "rows",
            "columns",
            "pages"
        ]
    },
    {
        "q": "Vectorized execution reduces function call overhead.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this vectorized comparison?",
        "type": "mcq",
        "c": "-- Row-at-a-time: Process 1 row per function call\n-- Vectorized: Process 1000 rows per function call\n-- For 1 million rows:",
        "o": [
            "Vectorized significantly faster",
            "Same performance",
            "Row-at-a-time faster",
            "Cannot compare"
        ]
    },
    {
        "q": "Match the execution model with its granularity:",
        "type": "match",
        "left": [
            "Tuple-at-a-time",
            "Operator-at-a-time",
            "Vector-at-a-time",
            "Column-at-a-time"
        ],
        "right": [
            "Single row",
            "Full operator",
            "Batch of rows",
            "Entire column"
        ]
    },
    {
        "q": "Rearrange the execution models by memory efficiency:",
        "type": "rearrange",
        "words": [
            "Tuple-at-a-time",
            "Vector-at-a-time",
            "Column-at-a-time",
            "Operator-at-a-time"
        ]
    },
    {
        "q": "What is predicate pushdown?",
        "type": "mcq",
        "o": [
            "Moving filter conditions closer to data source",
            "Pushing predicates to client",
            "Delaying predicate evaluation",
            "Combining multiple predicates"
        ]
    },
    {
        "q": "Predicate pushdown reduces _____ transferred between operators.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "queries",
            "connections",
            "transactions"
        ]
    },
    {
        "q": "Partition pruning is enabled by predicate pushdown.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this pushdown scenario?",
        "type": "mcq",
        "c": "-- Query: SELECT * FROM orders JOIN customers ON...\n--        WHERE orders.status = 'active'\n-- Without pushdown: Join first, then filter\n-- With pushdown:",
        "o": [
            "Filter orders before join, less data processed",
            "Same execution plan",
            "Filter after join only",
            "Query fails"
        ]
    },
    {
        "q": "Match the optimization with its effect:",
        "type": "match",
        "left": [
            "Predicate pushdown",
            "Projection pushdown",
            "Join reordering",
            "Subquery unnesting"
        ],
        "right": [
            "Early filtering",
            "Fetch fewer columns",
            "Optimal join sequence",
            "Flatten nested queries"
        ]
    },
    {
        "q": "Rearrange the query optimization rules by impact:",
        "type": "rearrange",
        "words": [
            "Predicate pushdown",
            "Join elimination",
            "Constant folding",
            "Column pruning"
        ]
    },
    {
        "q": "What is cardinality estimation?",
        "type": "mcq",
        "o": [
            "Estimating the number of rows a query will return",
            "Counting table rows",
            "Measuring column uniqueness",
            "Calculating index size"
        ]
    },
    {
        "q": "Poor cardinality estimates lead to _____ query plans.",
        "type": "fill_blank",
        "answers": [
            "suboptimal"
        ],
        "other_options": [
            "optimal",
            "failed",
            "cached"
        ]
    },
    {
        "q": "Histogram statistics help improve cardinality estimation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this estimation error?",
        "type": "mcq",
        "c": "-- Estimated rows: 100\n-- Actual rows: 1,000,000\n-- Optimizer chose: Nested loop join\n-- Better choice:",
        "o": [
            "Hash join would be much faster",
            "Nested loop is still optimal",
            "Query fails",
            "Both are equivalent"
        ]
    },
    {
        "q": "Match the statistics type with its information:",
        "type": "match",
        "left": [
            "Row count",
            "Distinct count",
            "Histogram",
            "Correlation"
        ],
        "right": [
            "Table size",
            "Column uniqueness",
            "Value distribution",
            "Column relationships"
        ]
    },
    {
        "q": "Rearrange the estimation accuracy factors:",
        "type": "rearrange",
        "words": [
            "Statistics freshness",
            "Histogram granularity",
            "Correlation awareness",
            "Expression estimation"
        ]
    },
    {
        "q": "What is adaptive query processing?",
        "type": "mcq",
        "o": [
            "Adjusting query execution based on runtime statistics",
            "Adapting to schema changes",
            "Query syntax correction",
            "Automatic indexing"
        ]
    },
    {
        "q": "Adaptive joins can switch _____ during execution.",
        "type": "fill_blank",
        "answers": [
            "algorithms"
        ],
        "other_options": [
            "tables",
            "columns",
            "databases"
        ]
    },
    {
        "q": "Adaptive query processing can correct for estimation errors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this adaptive scenario?",
        "type": "mcq",
        "c": "-- Estimated: Small result set, chose nested loop\n-- Runtime: Large result set detected\n-- Adaptive behavior:",
        "o": [
            "Switch to hash join mid-execution",
            "Continue with nested loop",
            "Restart query from beginning",
            "Query fails"
        ]
    },
    {
        "q": "Match the adaptive feature with its benefit:",
        "type": "match",
        "left": [
            "Adaptive joins",
            "Memory grants feedback",
            "Interleaved execution",
            "Query store"
        ],
        "right": [
            "Dynamic algorithm",
            "Right-sized memory",
            "Better subquery estimates",
            "Plan history"
        ]
    },
    {
        "q": "Rearrange the query plan adaptation levels:",
        "type": "rearrange",
        "words": [
            "Compile-time optimization",
            "Runtime adaptation",
            "Execution feedback",
            "Plan cache update"
        ]
    },
    {
        "q": "What is SQL injection?",
        "type": "mcq",
        "o": [
            "Inserting malicious SQL through user input",
            "Injecting stored procedures",
            "Adding SQL comments",
            "Importing SQL files"
        ]
    },
    {
        "q": "_____ queries prevent SQL injection by separating code from data.",
        "type": "fill_blank",
        "answers": [
            "Parameterized"
        ],
        "other_options": [
            "Dynamic",
            "Static",
            "Cached"
        ]
    },
    {
        "q": "Input validation alone is sufficient to prevent SQL injection.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this injection vulnerability?",
        "type": "mcq",
        "c": "-- Vulnerable: \"SELECT * FROM users WHERE id = \" + user_input\n-- User input: \"1 OR 1=1\"\n-- Result:",
        "o": [
            "Returns all users - security breach",
            "Returns only user 1",
            "Query syntax error",
            "Empty result set"
        ]
    },
    {
        "q": "Match the defense with its protection:",
        "type": "match",
        "left": [
            "Parameterized queries",
            "Input validation",
            "Least privilege",
            "WAF"
        ],
        "right": [
            "Separate code/data",
            "Reject bad input",
            "Limit damage",
            "Block attack patterns"
        ]
    },
    {
        "q": "Rearrange the SQL injection defense layers:",
        "type": "rearrange",
        "words": [
            "Input validation",
            "Parameterized queries",
            "Least privilege",
            "Monitoring",
            "WAF"
        ]
    },
    {
        "q": "What is database encryption at rest?",
        "type": "mcq",
        "o": [
            "Encrypting data stored on disk",
            "Encrypting network traffic",
            "Encrypting query results",
            "Encrypting backups only"
        ]
    },
    {
        "q": "TDE stands for _____ Data Encryption.",
        "type": "fill_blank",
        "answers": [
            "Transparent"
        ],
        "other_options": [
            "Total",
            "Transfer",
            "Temporal"
        ]
    },
    {
        "q": "TDE protects against physical theft of storage media.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this TDE scenario?",
        "type": "mcq",
        "c": "-- TDE enabled\n-- Database file stolen\n-- Attacker tries to read data",
        "o": [
            "Data unreadable without encryption key",
            "Data readable in clear text",
            "Some data readable",
            "Attacker gets key from file"
        ]
    },
    {
        "q": "Match the encryption type with its scope:",
        "type": "match",
        "left": [
            "TDE",
            "Column encryption",
            "SSL/TLS",
            "Application encryption"
        ],
        "right": [
            "All at rest",
            "Specific columns",
            "In transit",
            "Before database"
        ]
    },
    {
        "q": "Rearrange the encryption layers by scope:",
        "type": "rearrange",
        "words": [
            "Application encryption",
            "Column encryption",
            "TDE",
            "Storage encryption"
        ]
    },
    {
        "q": "What is database monitoring?",
        "type": "mcq",
        "o": [
            "Tracking database health and performance metrics",
            "Watching database files",
            "Logging user activity only",
            "Checking backup status"
        ]
    },
    {
        "q": "The _____ metric indicates disk I/O bottlenecks.",
        "type": "fill_blank",
        "answers": [
            "IOPS"
        ],
        "other_options": [
            "CPU",
            "memory",
            "connections"
        ]
    },
    {
        "q": "Proactive monitoring helps prevent outages.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this monitoring alert?",
        "type": "mcq",
        "c": "-- Alert: Buffer pool hit ratio dropped to 60%\n-- Normal: 99%\n-- Likely cause:",
        "o": [
            "Working set exceeds buffer pool size",
            "Disk failure",
            "Network issue",
            "Application bug"
        ]
    },
    {
        "q": "Match the metric with its concern:",
        "type": "match",
        "left": [
            "High CPU",
            "Low hit ratio",
            "Long locks",
            "Connection spike"
        ],
        "right": [
            "Query performance",
            "Memory shortage",
            "Concurrency issue",
            "Application issue"
        ]
    },
    {
        "q": "Rearrange the monitoring priority:",
        "type": "rearrange",
        "words": [
            "Availability",
            "Performance",
            "Security",
            "Capacity"
        ]
    },
    {
        "q": "What is database capacity planning?",
        "type": "mcq",
        "o": [
            "Predicting future resource needs",
            "Current capacity measurement",
            "Limiting database size",
            "Reducing storage costs"
        ]
    },
    {
        "q": "Capacity planning considers _____, storage, memory, and network.",
        "type": "fill_blank",
        "answers": [
            "CPU"
        ],
        "other_options": [
            "users",
            "tables",
            "indexes"
        ]
    },
    {
        "q": "Growth rate analysis is essential for capacity planning.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this capacity analysis?",
        "type": "mcq",
        "c": "-- Current storage: 500GB\n-- Monthly growth: 10%\n-- Time to 2TB limit:",
        "o": [
            "Approximately 14 months",
            "Approximately 3 months",
            "Approximately 40 months",
            "Cannot be calculated"
        ]
    },
    {
        "q": "Match the capacity factor with its metric:",
        "type": "match",
        "left": [
            "Storage growth",
            "Query load",
            "Connection demand",
            "Index bloat"
        ],
        "right": [
            "GB per month",
            "Queries per second",
            "Concurrent users",
            "Index size ratio"
        ]
    },
    {
        "q": "Rearrange the capacity planning process:",
        "type": "rearrange",
        "words": [
            "Baseline current usage",
            "Analyze growth trends",
            "Forecast requirements",
            "Plan upgrades",
            "Monitor and adjust"
        ]
    },
    {
        "q": "What is a database query profiler?",
        "type": "mcq",
        "o": [
            "Tool for analyzing query performance",
            "User authentication system",
            "Query result formatter",
            "Database backup tool"
        ]
    },
    {
        "q": "The _____ view in PostgreSQL shows running queries.",
        "type": "fill_blank",
        "answers": [
            "pg_stat_activity"
        ],
        "other_options": [
            "pg_queries",
            "pg_running",
            "pg_processes"
        ]
    },
    {
        "q": "Query profiling adds overhead to query execution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this profiling query?",
        "type": "mcq",
        "c": "SELECT query, calls, mean_time, total_time\nFROM pg_stat_statements\nORDER BY total_time DESC LIMIT 5;",
        "o": [
            "Top 5 queries by cumulative execution time",
            "5 random queries",
            "Last 5 queries executed",
            "5 failed queries"
        ]
    },
    {
        "q": "Match the profiling metric with its insight:",
        "type": "match",
        "left": [
            "Total time",
            "Mean time",
            "Call count",
            "Rows returned"
        ],
        "right": [
            "Cumulative impact",
            "Per-execution cost",
            "Frequency",
            "Result size"
        ]
    },
    {
        "q": "Rearrange the query optimization workflow:",
        "type": "rearrange",
        "words": [
            "Profile queries",
            "Identify slow queries",
            "Analyze plans",
            "Apply optimizations",
            "Measure improvement"
        ]
    },
    {
        "q": "What is online schema migration?",
        "type": "mcq",
        "o": [
            "Changing schema without blocking operations",
            "Migrating to a new database",
            "Schema backup process",
            "Schema version control"
        ]
    },
    {
        "q": "Ghost and _____ are popular online migration tools.",
        "type": "fill_blank",
        "answers": [
            "pt-online-schema-change"
        ],
        "other_options": [
            "pg_dump",
            "mysqldump",
            "alembic"
        ]
    },
    {
        "q": "Online migrations typically use shadow table approach.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this migration scenario?",
        "type": "mcq",
        "c": "-- Online migration: Add column to 100GB table\n-- Tool: Uses shadow table + triggers\n-- During migration:",
        "o": [
            "Reads and writes continue normally",
            "Table is locked for writes",
            "Table is completely offline",
            "Only reads allowed"
        ]
    },
    {
        "q": "Match the migration approach with its trade-off:",
        "type": "match",
        "left": [
            "ALTER TABLE",
            "Shadow table",
            "Expand-contract",
            "Blue-green"
        ],
        "right": [
            "Simple but locks",
            "No locks but complex",
            "Gradual transition",
            "Full cutover"
        ]
    },
    {
        "q": "Rearrange the expand-contract migration phases:",
        "type": "rearrange",
        "words": [
            "Expand (add new)",
            "Migrate data",
            "Transition code",
            "Contract (remove old)"
        ]
    },
    {
        "q": "What is database observability?",
        "type": "mcq",
        "o": [
            "Understanding internal state through external outputs",
            "Watching database logs",
            "Performance testing",
            "Security auditing"
        ]
    },
    {
        "q": "The three pillars of observability are logs, metrics, and _____.",
        "type": "fill_blank",
        "answers": [
            "traces"
        ],
        "other_options": [
            "alerts",
            "dashboards",
            "reports"
        ]
    },
    {
        "q": "Distributed tracing helps debug cross-service database queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this tracing scenario?",
        "type": "mcq",
        "c": "-- Trace: User request to checkout\n-- Spans: API -> Order Service -> Database -> Payment Service\n-- Database span shows: 500ms\n-- Insight:",
        "o": [
            "Database query is bottleneck",
            "Network is bottleneck",
            "All services equal",
            "No useful information"
        ]
    },
    {
        "q": "Match the observability pillar with its use:",
        "type": "match",
        "left": [
            "Logs",
            "Metrics",
            "Traces",
            "Events"
        ],
        "right": [
            "Detailed debugging",
            "Trend analysis",
            "Request flow",
            "State changes"
        ]
    },
    {
        "q": "Rearrange the observability implementation order:",
        "type": "rearrange",
        "words": [
            "Define metrics",
            "Set up logging",
            "Implement tracing",
            "Create dashboards",
            "Configure alerts"
        ]
    },
    {
        "q": "What is database backup strategy?",
        "type": "mcq",
        "o": [
            "Plan for creating and maintaining database copies",
            "Deleting old data",
            "Compressing database files",
            "Moving data to archive"
        ]
    },
    {
        "q": "The _____ backup captures only changes since the last backup.",
        "type": "fill_blank",
        "answers": [
            "incremental"
        ],
        "other_options": [
            "full",
            "differential",
            "complete"
        ]
    },
    {
        "q": "Point-in-time recovery requires transaction logs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this backup scenario?",
        "type": "mcq",
        "c": "-- Full backup: Sunday\n-- Incremental: Daily\n-- Recovery needed: Wednesday data\n-- Restore sequence:",
        "o": [
            "Full + Monday + Tuesday + Wednesday incrementals",
            "Wednesday incremental only",
            "Full backup only",
            "All incrementals without full"
        ]
    },
    {
        "q": "Match the backup type with its characteristic:",
        "type": "match",
        "left": [
            "Full",
            "Differential",
            "Incremental",
            "Continuous"
        ],
        "right": [
            "Complete copy",
            "Changes since full",
            "Changes since last",
            "Real-time sync"
        ]
    },
    {
        "q": "Rearrange the backup strategy by recovery speed:",
        "type": "rearrange",
        "words": [
            "Daily full",
            "Full + differential",
            "Full + incremental",
            "Continuous replication"
        ]
    },
    {
        "q": "What is disaster recovery (DR)?",
        "type": "mcq",
        "o": [
            "Process to recover from catastrophic failures",
            "Regular database maintenance",
            "Performance optimization",
            "Security patching"
        ]
    },
    {
        "q": "RTO stands for Recovery _____ Objective.",
        "type": "fill_blank",
        "answers": [
            "Time"
        ],
        "other_options": [
            "Target",
            "Test",
            "Total"
        ]
    },
    {
        "q": "RPO determines acceptable data loss.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this DR requirement?",
        "type": "mcq",
        "c": "-- RPO: 15 minutes\n-- RTO: 1 hour\n-- Required backup frequency:",
        "o": [
            "At least every 15 minutes",
            "Once per hour",
            "Once per day",
            "Once per week"
        ]
    },
    {
        "q": "Match the DR term with its meaning:",
        "type": "match",
        "left": [
            "RTO",
            "RPO",
            "Hot standby",
            "Cold standby"
        ],
        "right": [
            "Max downtime",
            "Max data loss",
            "Always running",
            "Start when needed"
        ]
    },
    {
        "q": "Rearrange the DR site types by cost:",
        "type": "rearrange",
        "words": [
            "Cold site",
            "Warm site",
            "Hot site",
            "Active-active"
        ]
    },
    {
        "q": "What is table inheritance in PostgreSQL?",
        "type": "mcq",
        "o": [
            "Child tables inheriting columns from parent tables",
            "Copying table data",
            "Table partitioning",
            "View inheritance"
        ]
    },
    {
        "q": "The _____ keyword indicates a query should include child tables.",
        "type": "fill_blank",
        "answers": [
            "ONLY"
        ],
        "other_options": [
            "ALL",
            "INCLUDE",
            "WITH"
        ]
    },
    {
        "q": "Child tables can add columns to inherited structure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this inheritance query?",
        "type": "mcq",
        "c": "-- Parent: vehicles (id, type)\n-- Child: cars INHERITS (vehicles) + (doors)\n-- Query: SELECT * FROM vehicles;",
        "o": [
            "Returns rows from both vehicles and cars",
            "Returns only vehicles rows",
            "Returns only cars rows",
            "Error - cannot query parent"
        ]
    },
    {
        "q": "Match the inheritance concept with its behavior:",
        "type": "match",
        "left": [
            "INHERITS",
            "ONLY clause",
            "CHECK constraint",
            "Trigger inheritance"
        ],
        "right": [
            "Create child table",
            "Exclude children",
            "Partition routing",
            "Auto-applied to children"
        ]
    },
    {
        "q": "Rearrange the table design patterns by flexibility:",
        "type": "rearrange",
        "words": [
            "Single table",
            "Inheritance",
            "Partitioning",
            "Separate tables"
        ]
    },
    {
        "q": "What is a tablespace in SQL?",
        "type": "mcq",
        "o": [
            "Logical storage location for database objects",
            "Space between tables",
            "Table size limit",
            "Temporary storage"
        ]
    },
    {
        "q": "Tablespaces allow placing tables on different _____.",
        "type": "fill_blank",
        "answers": [
            "disks"
        ],
        "other_options": [
            "servers",
            "databases",
            "schemas"
        ]
    },
    {
        "q": "Using SSD tablespace for hot data improves performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this tablespace usage?",
        "type": "mcq",
        "c": "CREATE TABLESPACE fast_storage LOCATION '/ssd/data';\nCREATE TABLE hot_data (...) TABLESPACE fast_storage;",
        "o": [
            "Table created on SSD storage",
            "Table created on default storage",
            "Tablespace creation fails",
            "Table is not created"
        ]
    },
    {
        "q": "Match the storage concept with its purpose:",
        "type": "match",
        "left": [
            "Tablespace",
            "Data file",
            "Redo log",
            "Control file"
        ],
        "right": [
            "Logical grouping",
            "Physical storage",
            "Change tracking",
            "Database metadata"
        ]
    },
    {
        "q": "Rearrange the storage tiers by speed:",
        "type": "rearrange",
        "words": [
            "RAM",
            "NVMe SSD",
            "SATA SSD",
            "HDD",
            "Archive"
        ]
    },
    {
        "q": "What is database vacuuming?",
        "type": "mcq",
        "o": [
            "Reclaiming storage from deleted rows",
            "Cleaning query cache",
            "Removing unused tables",
            "Defragmenting indexes"
        ]
    },
    {
        "q": "PostgreSQL requires _____ to prevent transaction ID wraparound.",
        "type": "fill_blank",
        "answers": [
            "vacuum"
        ],
        "other_options": [
            "analyze",
            "reindex",
            "cluster"
        ]
    },
    {
        "q": "Autovacuum runs automatically in the background.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this vacuum scenario?",
        "type": "mcq",
        "c": "-- Table: 1M rows\n-- Deleted: 900K rows\n-- Before VACUUM: Table size 100MB\n-- After VACUUM FULL:",
        "o": [
            "Table size significantly reduced",
            "Table size unchanged",
            "Only statistics updated",
            "Table dropped"
        ]
    },
    {
        "q": "Match the vacuum type with its action:",
        "type": "match",
        "left": [
            "Plain VACUUM",
            "VACUUM FULL",
            "VACUUM ANALYZE",
            "Autovacuum"
        ],
        "right": [
            "Mark space reusable",
            "Compact and reclaim",
            "Update statistics too",
            "Automatic maintenance"
        ]
    },
    {
        "q": "Rearrange the maintenance tasks by frequency:",
        "type": "rearrange",
        "words": [
            "Autovacuum (continuous)",
            "Analyze (daily)",
            "Reindex (weekly)",
            "VACUUM FULL (rarely)"
        ]
    },
    {
        "q": "What is query parameterization?",
        "type": "mcq",
        "o": [
            "Using placeholders instead of literal values in queries",
            "Adding parameters to stored procedures",
            "Configuring database settings",
            "Setting query timeouts"
        ]
    },
    {
        "q": "Parameterized queries help prevent _____ injection.",
        "type": "fill_blank",
        "answers": [
            "SQL"
        ],
        "other_options": [
            "code",
            "data",
            "script"
        ]
    },
    {
        "q": "Parameterized queries can improve plan cache efficiency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this prepared query?",
        "type": "mcq",
        "c": "PREPARE find_user(int) AS SELECT * FROM users WHERE id = $1;\nEXECUTE find_user(5);",
        "o": [
            "Returns user with id 5",
            "Returns all users",
            "Syntax error",
            "Returns nothing"
        ]
    },
    {
        "q": "Match the query type with its security level:",
        "type": "match",
        "left": [
            "String concatenation",
            "Parameterized",
            "Stored procedure",
            "ORM query"
        ],
        "right": [
            "Vulnerable",
            "Safe",
            "Encapsulated",
            "Usually safe"
        ]
    },
    {
        "q": "Rearrange the query safety measures:",
        "type": "rearrange",
        "words": [
            "Input validation",
            "Parameterization",
            "Least privilege",
            "Query whitelisting"
        ]
    },
    {
        "q": "What is database connection string?",
        "type": "mcq",
        "o": [
            "Configuration string containing connection parameters",
            "SQL query string",
            "Error message",
            "Log entry"
        ]
    },
    {
        "q": "Connection strings typically include host, port, database, and _____.",
        "type": "fill_blank",
        "answers": [
            "credentials"
        ],
        "other_options": [
            "queries",
            "tables",
            "schemas"
        ]
    },
    {
        "q": "Connection strings should not be stored in plain text in code.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this connection string?",
        "type": "mcq",
        "c": "postgresql://user:pass@localhost:5432/mydb?sslmode=require",
        "o": [
            "Connects to PostgreSQL with SSL required",
            "Creates a new database",
            "Backs up the database",
            "Lists all databases"
        ]
    },
    {
        "q": "Match the connection parameter with its purpose:",
        "type": "match",
        "left": [
            "host",
            "port",
            "sslmode",
            "connect_timeout"
        ],
        "right": [
            "Server address",
            "Network port",
            "Encryption setting",
            "Max wait time"
        ]
    },
    {
        "q": "Rearrange the connection security layers:",
        "type": "rearrange",
        "words": [
            "Encrypted credentials",
            "SSL/TLS transport",
            "Firewall rules",
            "Database authentication"
        ]
    },
    {
        "q": "What is a database cursor?",
        "type": "mcq",
        "o": [
            "Pointer to query result set for row-by-row processing",
            "Mouse pointer in database GUI",
            "Index pointer",
            "Transaction marker"
        ]
    },
    {
        "q": "The _____ command retrieves rows from a cursor.",
        "type": "fill_blank",
        "answers": [
            "FETCH"
        ],
        "other_options": [
            "GET",
            "READ",
            "NEXT"
        ]
    },
    {
        "q": "Server-side cursors reduce memory usage for large result sets.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this cursor usage?",
        "type": "mcq",
        "c": "DECLARE my_cursor CURSOR FOR SELECT * FROM large_table;\nFETCH 100 FROM my_cursor;",
        "o": [
            "Returns first 100 rows",
            "Returns all rows",
            "Counts to 100",
            "Error - invalid syntax"
        ]
    },
    {
        "q": "Match the cursor type with its behavior:",
        "type": "match",
        "left": [
            "Forward-only",
            "Scrollable",
            "Insensitive",
            "Sensitive"
        ],
        "right": [
            "Sequential access",
            "Random access",
            "Snapshot data",
            "Live data"
        ]
    },
    {
        "q": "Rearrange cursor operations:",
        "type": "rearrange",
        "words": [
            "DECLARE",
            "OPEN",
            "FETCH",
            "CLOSE",
            "DEALLOCATE"
        ]
    },
    {
        "q": "What is a database synonym?",
        "type": "mcq",
        "o": [
            "Alias for a database object",
            "Similar table structure",
            "Duplicate data",
            "Backup name"
        ]
    },
    {
        "q": "Public synonyms are accessible to all _____ in the database.",
        "type": "fill_blank",
        "answers": [
            "users"
        ],
        "other_options": [
            "tables",
            "schemas",
            "roles"
        ]
    },
    {
        "q": "Synonyms can simplify cross-schema object references.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this synonym usage?",
        "type": "mcq",
        "c": "CREATE SYNONYM emp FOR hr.employees;\nSELECT * FROM emp;",
        "o": [
            "Queries hr.employees using shorter name",
            "Creates a copy of the table",
            "Error - synonyms not supported",
            "Queries a different table"
        ]
    },
    {
        "q": "Match the alias type with its scope:",
        "type": "match",
        "left": [
            "Table alias",
            "Column alias",
            "Synonym",
            "View"
        ],
        "right": [
            "Query scope",
            "Query scope",
            "Database scope",
            "Permanent object"
        ]
    },
    {
        "q": "Rearrange the abstraction levels:",
        "type": "rearrange",
        "words": [
            "Direct table access",
            "Synonyms",
            "Views",
            "Stored procedures",
            "API layer"
        ]
    },
    {
        "q": "What is database event notification?",
        "type": "mcq",
        "o": [
            "Mechanism to notify applications of database changes",
            "Error logging",
            "Performance alerts",
            "Backup completion"
        ]
    },
    {
        "q": "PostgreSQL uses _____ and LISTEN for pub/sub notifications.",
        "type": "fill_blank",
        "answers": [
            "NOTIFY"
        ],
        "other_options": [
            "PUBLISH",
            "SEND",
            "BROADCAST"
        ]
    },
    {
        "q": "Database notifications enable real-time updates to applications.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this notification?",
        "type": "mcq",
        "c": "-- Session 1: LISTEN order_updates;\n-- Session 2: NOTIFY order_updates, 'new order 123';",
        "o": [
            "Session 1 receives notification with payload",
            "Session 2 receives the notification",
            "Both sessions receive notification",
            "Notification is lost"
        ]
    },
    {
        "q": "Match the notification pattern with its use case:",
        "type": "match",
        "left": [
            "LISTEN/NOTIFY",
            "Change Data Capture",
            "Triggers",
            "Polling"
        ],
        "right": [
            "Real-time pub/sub",
            "Stream changes",
            "Immediate reaction",
            "Periodic check"
        ]
    },
    {
        "q": "Rearrange the change detection methods by efficiency:",
        "type": "rearrange",
        "words": [
            "Polling",
            "Timestamp checking",
            "Triggers",
            "LISTEN/NOTIFY",
            "CDC"
        ]
    },
    {
        "q": "What is logical decoding?",
        "type": "mcq",
        "o": [
            "Converting WAL changes to logical format",
            "Decoding query plans",
            "Parsing SQL statements",
            "Decompressing data"
        ]
    },
    {
        "q": "Logical replication uses _____ slots to track changes.",
        "type": "fill_blank",
        "answers": [
            "replication"
        ],
        "other_options": [
            "memory",
            "disk",
            "network"
        ]
    },
    {
        "q": "Logical decoding enables heterogeneous replication.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this logical replication?",
        "type": "mcq",
        "c": "-- Source: PostgreSQL\n-- Target: Different database system\n-- Method: Logical decoding + custom consumer",
        "o": [
            "Changes streamed to target in readable format",
            "Binary replication only",
            "Replication fails",
            "Target must be PostgreSQL"
        ]
    },
    {
        "q": "Match the replication type with its data format:",
        "type": "match",
        "left": [
            "Physical",
            "Logical",
            "Statement-based",
            "Row-based"
        ],
        "right": [
            "Binary WAL",
            "Decoded changes",
            "SQL commands",
            "Row changes"
        ]
    },
    {
        "q": "Rearrange the replication methods by flexibility:",
        "type": "rearrange",
        "words": [
            "Physical replication",
            "Row-based logical",
            "Statement-based logical",
            "Custom CDC"
        ]
    },
    {
        "q": "What is query timeout?",
        "type": "mcq",
        "o": [
            "Maximum time allowed for query execution",
            "Connection timeout",
            "Lock timeout",
            "Transaction timeout"
        ]
    },
    {
        "q": "Setting statement_timeout helps prevent _____ queries.",
        "type": "fill_blank",
        "answers": [
            "runaway"
        ],
        "other_options": [
            "slow",
            "complex",
            "large"
        ]
    },
    {
        "q": "Query timeout cancels the query but preserves the connection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this timeout scenario?",
        "type": "mcq",
        "c": "SET statement_timeout = '5s';\nSELECT * FROM huge_table; -- Takes 30 seconds",
        "o": [
            "Query cancelled after 5 seconds",
            "Query completes after 30 seconds",
            "Connection closed",
            "Query runs indefinitely"
        ]
    },
    {
        "q": "Match the timeout type with its scope:",
        "type": "match",
        "left": [
            "statement_timeout",
            "lock_timeout",
            "idle_in_transaction_timeout",
            "connect_timeout"
        ],
        "right": [
            "Query execution",
            "Waiting for locks",
            "Idle transactions",
            "Connection establishment"
        ]
    },
    {
        "q": "Rearrange the resource limits by impact:",
        "type": "rearrange",
        "words": [
            "Query timeout",
            "Memory limit",
            "Connection limit",
            "Disk quota"
        ]
    },
    {
        "q": "What is database rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting the number of operations per time period",
            "Reducing data transfer speed",
            "Throttling disk I/O",
            "Limiting table size"
        ]
    },
    {
        "q": "Rate limiting protects against _____ attacks.",
        "type": "fill_blank",
        "answers": [
            "DoS"
        ],
        "other_options": [
            "SQL",
            "injection",
            "malware"
        ]
    },
    {
        "q": "Connection pooling can help implement rate limiting.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this rate limit?",
        "type": "mcq",
        "c": "-- Rate limit: 100 queries per second per user\n-- User tries: 150 queries in 1 second",
        "o": [
            "50 queries rejected or queued",
            "All queries processed",
            "User connection closed",
            "Database shuts down"
        ]
    },
    {
        "q": "Match the limit type with its protection:",
        "type": "match",
        "left": [
            "Query rate limit",
            "Connection limit",
            "Memory limit",
            "Timeout"
        ],
        "right": [
            "Prevent overload",
            "Prevent exhaustion",
            "Prevent OOM",
            "Prevent hung queries"
        ]
    },
    {
        "q": "Rearrange the protection measures by layer:",
        "type": "rearrange",
        "words": [
            "Network firewall",
            "Connection pool",
            "Query rate limit",
            "Resource governor"
        ]
    },
    {
        "q": "What is query result caching?",
        "type": "mcq",
        "o": [
            "Storing query results for reuse",
            "Caching query plans",
            "Caching table data",
            "Caching indexes"
        ]
    },
    {
        "q": "Result cache invalidation is triggered by _____ changes.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "schema",
            "permission",
            "connection"
        ]
    },
    {
        "q": "Caching is most effective for read-heavy workloads.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this caching scenario?",
        "type": "mcq",
        "c": "-- Query: SELECT * FROM products WHERE category = 'books'\n-- First run: 100ms (cache miss)\n-- Second run with unchanged data:",
        "o": [
            "Much faster (cache hit)",
            "Same time",
            "Slower",
            "Query fails"
        ]
    },
    {
        "q": "Match the cache location with its latency:",
        "type": "match",
        "left": [
            "Application cache",
            "Connection cache",
            "Database cache",
            "Disk cache"
        ],
        "right": [
            "Fastest",
            "Fast",
            "Medium",
            "Slowest"
        ]
    },
    {
        "q": "Rearrange the caching strategies by data freshness:",
        "type": "rearrange",
        "words": [
            "No cache",
            "Short TTL",
            "Long TTL",
            "Invalidation-based",
            "Infinite cache"
        ]
    },
    {
        "q": "What is read replica?",
        "type": "mcq",
        "o": [
            "Database copy that handles read queries",
            "Backup database",
            "Test database",
            "Archive database"
        ]
    },
    {
        "q": "Read replicas help scale _____ operations.",
        "type": "fill_blank",
        "answers": [
            "read"
        ],
        "other_options": [
            "write",
            "delete",
            "update"
        ]
    },
    {
        "q": "Read replicas may have slight replication lag.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this replica scenario?",
        "type": "mcq",
        "c": "-- Primary: Handles all writes\n-- 3 Read replicas: Handle reads\n-- Application reads: ",
        "o": [
            "Distributed across replicas",
            "All go to primary",
            "Random database selected",
            "Reads fail"
        ]
    },
    {
        "q": "Match the replica role with its purpose:",
        "type": "match",
        "left": [
            "Primary",
            "Read replica",
            "Standby",
            "Delayed replica"
        ],
        "right": [
            "Write handling",
            "Read scaling",
            "Failover target",
            "Point-in-time recovery"
        ]
    },
    {
        "q": "Rearrange database scaling strategies:",
        "type": "rearrange",
        "words": [
            "Vertical scaling",
            "Read replicas",
            "Sharding",
            "Distributed database"
        ]
    },
    {
        "q": "What is database connection timeout?",
        "type": "mcq",
        "o": [
            "Maximum time to establish a connection",
            "Maximum query duration",
            "Maximum idle time",
            "Maximum transaction time"
        ]
    },
    {
        "q": "Connection timeout prevents applications from _____ indefinitely.",
        "type": "fill_blank",
        "answers": [
            "waiting"
        ],
        "other_options": [
            "running",
            "connecting",
            "querying"
        ]
    },
    {
        "q": "Network issues can cause connection timeouts.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this timeout scenario?",
        "type": "mcq",
        "c": "-- connect_timeout: 5 seconds\n-- Database server: Unreachable\n-- Connection attempt:",
        "o": [
            "Fails after 5 seconds with timeout error",
            "Waits indefinitely",
            "Connects to backup server",
            "Retries automatically forever"
        ]
    },
    {
        "q": "Match the connection issue with its cause:",
        "type": "match",
        "left": [
            "Connection timeout",
            "Connection refused",
            "Authentication failure",
            "Too many connections"
        ],
        "right": [
            "Network/firewall",
            "Server not running",
            "Wrong credentials",
            "Pool exhausted"
        ]
    },
    {
        "q": "Rearrange connection troubleshooting steps:",
        "type": "rearrange",
        "words": [
            "Check network",
            "Verify server running",
            "Check credentials",
            "Review pool settings",
            "Check firewalls"
        ]
    },
    {
        "q": "What is slow query logging?",
        "type": "mcq",
        "o": [
            "Recording queries that exceed time threshold",
            "Logging all queries",
            "Logging query errors",
            "Logging connection attempts"
        ]
    },
    {
        "q": "The _____ parameter sets the threshold for slow query logging.",
        "type": "fill_blank",
        "answers": [
            "log_min_duration_statement"
        ],
        "other_options": [
            "slow_query_log",
            "query_log_time",
            "log_threshold"
        ]
    },
    {
        "q": "Slow query logs help identify performance bottlenecks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this logging config?",
        "type": "mcq",
        "c": "-- log_min_duration_statement = 1000 (ms)\n-- Query takes 500ms\n-- Log behavior:",
        "o": [
            "Query not logged (below threshold)",
            "Query logged",
            "Error thrown",
            "Query cancelled"
        ]
    },
    {
        "q": "Match the log type with its content:",
        "type": "match",
        "left": [
            "Slow query log",
            "Error log",
            "General log",
            "Audit log"
        ],
        "right": [
            "Long-running queries",
            "Errors and warnings",
            "All statements",
            "Security events"
        ]
    }
]